/**
 * Copyright (c) 2021-2022 Huawei Device Co., Ltd.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Autogenerated file -- DO NOT EDIT!

#include <lexer/keywordString.h>
#include <utils/span.h>

namespace panda::es2panda::lexer {

class KeywordsMap {
public:
    KeywordsMap() = delete;

    static Span<const KeywordString> Map(char32_t cp) {
        switch(cp) {
        case LEX_CHAR_LOWERCASE_A: {
            return Span<const KeywordString>(KEYWORDS_A);
        }
        case LEX_CHAR_LOWERCASE_B: {
            return Span<const KeywordString>(KEYWORDS_B);
        }
        case LEX_CHAR_LOWERCASE_C: {
            return Span<const KeywordString>(KEYWORDS_C);
        }
        case LEX_CHAR_LOWERCASE_D: {
            return Span<const KeywordString>(KEYWORDS_D);
        }
        case LEX_CHAR_LOWERCASE_E: {
            return Span<const KeywordString>(KEYWORDS_E);
        }
        case LEX_CHAR_LOWERCASE_F: {
            return Span<const KeywordString>(KEYWORDS_F);
        }
        case LEX_CHAR_LOWERCASE_G: {
            return Span<const KeywordString>(KEYWORDS_G);
        }
        case LEX_CHAR_LOWERCASE_I: {
            return Span<const KeywordString>(KEYWORDS_I);
        }
        case LEX_CHAR_LOWERCASE_K: {
            return Span<const KeywordString>(KEYWORDS_K);
        }
        case LEX_CHAR_LOWERCASE_L: {
            return Span<const KeywordString>(KEYWORDS_L);
        }
        case LEX_CHAR_LOWERCASE_M: {
            return Span<const KeywordString>(KEYWORDS_M);
        }
        case LEX_CHAR_LOWERCASE_N: {
            return Span<const KeywordString>(KEYWORDS_N);
        }
        case LEX_CHAR_LOWERCASE_O: {
            return Span<const KeywordString>(KEYWORDS_O);
        }
        case LEX_CHAR_LOWERCASE_P: {
            return Span<const KeywordString>(KEYWORDS_P);
        }
        case LEX_CHAR_LOWERCASE_R: {
            return Span<const KeywordString>(KEYWORDS_R);
        }
        case LEX_CHAR_LOWERCASE_S: {
            return Span<const KeywordString>(KEYWORDS_S);
        }
        case LEX_CHAR_LOWERCASE_T: {
            return Span<const KeywordString>(KEYWORDS_T);
        }
        case LEX_CHAR_LOWERCASE_U: {
            return Span<const KeywordString>(KEYWORDS_U);
        }
        case LEX_CHAR_LOWERCASE_V: {
            return Span<const KeywordString>(KEYWORDS_V);
        }
        case LEX_CHAR_LOWERCASE_W: {
            return Span<const KeywordString>(KEYWORDS_W);
        }
        case LEX_CHAR_LOWERCASE_Y: {
            return Span<const KeywordString>(KEYWORDS_Y);
        }
        default: {
            return Span<const KeywordString>();
        }
        }
    }


    static constexpr std::array<const KeywordString, 7> KEYWORDS_A = {{
        {"abstract", TokenType::LITERAL_IDENT, TokenType::KEYW_ABSTRACT},
        {"any", TokenType::LITERAL_IDENT, TokenType::KEYW_ANY},
        {"arguments", TokenType::LITERAL_IDENT, TokenType::KEYW_ARGUMENTS},
        {"as", TokenType::LITERAL_IDENT, TokenType::KEYW_AS},
        {"asserts", TokenType::LITERAL_IDENT, TokenType::KEYW_ASSERTS},
        {"async", TokenType::LITERAL_IDENT, TokenType::KEYW_ASYNC},
        {"await", TokenType::LITERAL_IDENT, TokenType::KEYW_AWAIT},
    }};

    static constexpr std::array<const KeywordString, 3> KEYWORDS_B = {{
        {"bigint", TokenType::LITERAL_IDENT, TokenType::KEYW_BIGINT},
        {"boolean", TokenType::LITERAL_IDENT, TokenType::KEYW_BOOLEAN},
        {"break", TokenType::KEYW_BREAK, TokenType::KEYW_BREAK},
    }};

    static constexpr std::array<const KeywordString, 5> KEYWORDS_C = {{
        {"case", TokenType::KEYW_CASE, TokenType::KEYW_CASE},
        {"catch", TokenType::KEYW_CATCH, TokenType::KEYW_CATCH},
        {"class", TokenType::KEYW_CLASS, TokenType::KEYW_CLASS},
        {"const", TokenType::KEYW_CONST, TokenType::KEYW_CONST},
        {"continue", TokenType::KEYW_CONTINUE, TokenType::KEYW_CONTINUE},
    }};

    static constexpr std::array<const KeywordString, 5> KEYWORDS_D = {{
        {"debugger", TokenType::KEYW_DEBUGGER, TokenType::KEYW_DEBUGGER},
        {"declare", TokenType::KEYW_DECLARE, TokenType::KEYW_DECLARE},
        {"default", TokenType::KEYW_DEFAULT, TokenType::KEYW_DEFAULT},
        {"delete", TokenType::KEYW_DELETE, TokenType::KEYW_DELETE},
        {"do", TokenType::KEYW_DO, TokenType::KEYW_DO},
    }};

    static constexpr std::array<const KeywordString, 5> KEYWORDS_E = {{
        {"else", TokenType::KEYW_ELSE, TokenType::KEYW_ELSE},
        {"enum", TokenType::LITERAL_IDENT, TokenType::KEYW_ENUM},
        {"eval", TokenType::LITERAL_IDENT, TokenType::KEYW_EVAL},
        {"export", TokenType::KEYW_EXPORT, TokenType::KEYW_EXPORT},
        {"extends", TokenType::KEYW_EXTENDS, TokenType::KEYW_EXTENDS},
    }};

    static constexpr std::array<const KeywordString, 5> KEYWORDS_F = {{
        {"false", TokenType::LITERAL_FALSE, TokenType::LITERAL_FALSE},
        {"finally", TokenType::KEYW_FINALLY, TokenType::KEYW_FINALLY},
        {"for", TokenType::KEYW_FOR, TokenType::KEYW_FOR},
        {"from", TokenType::LITERAL_IDENT, TokenType::KEYW_FROM},
        {"function", TokenType::KEYW_FUNCTION, TokenType::KEYW_FUNCTION},
    }};

    static constexpr std::array<const KeywordString, 2> KEYWORDS_G = {{
        {"get", TokenType::LITERAL_IDENT, TokenType::KEYW_GET},
        {"global", TokenType::LITERAL_IDENT, TokenType::KEYW_GLOBAL},
    }};

    static constexpr std::array<const KeywordString, 8> KEYWORDS_I = {{
        {"if", TokenType::KEYW_IF, TokenType::KEYW_IF},
        {"implements", TokenType::KEYW_IMPLEMENTS, TokenType::KEYW_IMPLEMENTS},
        {"import", TokenType::KEYW_IMPORT, TokenType::KEYW_IMPORT},
        {"in", TokenType::KEYW_IN, TokenType::KEYW_IN},
        {"infer", TokenType::LITERAL_IDENT, TokenType::KEYW_INFER},
        {"instanceof", TokenType::KEYW_INSTANCEOF, TokenType::KEYW_INSTANCEOF},
        {"interface", TokenType::LITERAL_IDENT, TokenType::KEYW_INTERFACE},
        {"is", TokenType::LITERAL_IDENT, TokenType::KEYW_IS},
    }};

    static constexpr std::array<const KeywordString, 1> KEYWORDS_K = {{
        {"keyof", TokenType::LITERAL_IDENT, TokenType::KEYW_KEYOF},
    }};

    static constexpr std::array<const KeywordString, 1> KEYWORDS_L = {{
        {"let", TokenType::KEYW_LET, TokenType::KEYW_LET},
    }};

    static constexpr std::array<const KeywordString, 3> KEYWORDS_M = {{
        {"meta", TokenType::LITERAL_IDENT, TokenType::KEYW_META},
        {"module", TokenType::LITERAL_IDENT, TokenType::KEYW_MODULE},
        {"namespace", TokenType::LITERAL_IDENT, TokenType::KEYW_NAMESPACE},
    }};

    static constexpr std::array<const KeywordString, 4> KEYWORDS_N = {{
        {"never", TokenType::LITERAL_IDENT, TokenType::KEYW_NEVER},
        {"new", TokenType::KEYW_NEW, TokenType::KEYW_NEW},
        {"null", TokenType::LITERAL_NULL, TokenType::LITERAL_NULL},
        {"number", TokenType::LITERAL_IDENT, TokenType::KEYW_NUMBER},
    }};

    static constexpr std::array<const KeywordString, 2> KEYWORDS_O = {{
        {"object", TokenType::LITERAL_IDENT, TokenType::KEYW_OBJECT},
        {"of", TokenType::LITERAL_IDENT, TokenType::KEYW_OF},
    }};

    static constexpr std::array<const KeywordString, 4> KEYWORDS_P = {{
        {"package", TokenType::KEYW_PACKAGE, TokenType::KEYW_PACKAGE},
        {"private", TokenType::KEYW_PRIVATE, TokenType::KEYW_PRIVATE},
        {"protected", TokenType::KEYW_PROTECTED, TokenType::KEYW_PROTECTED},
        {"public", TokenType::KEYW_PUBLIC, TokenType::KEYW_PUBLIC},
    }};

    static constexpr std::array<const KeywordString, 3> KEYWORDS_R = {{
        {"readonly", TokenType::LITERAL_IDENT, TokenType::KEYW_READONLY},
        {"return", TokenType::KEYW_RETURN, TokenType::KEYW_RETURN},
        {"require", TokenType::LITERAL_IDENT, TokenType::KEYW_REQUIRE},
    }};

    static constexpr std::array<const KeywordString, 6> KEYWORDS_S = {{
        {"set", TokenType::LITERAL_IDENT, TokenType::KEYW_SET},
        {"static", TokenType::LITERAL_IDENT, TokenType::KEYW_STATIC},
        {"string", TokenType::LITERAL_IDENT, TokenType::KEYW_STRING},
        {"super", TokenType::KEYW_SUPER, TokenType::KEYW_SUPER},
        {"switch", TokenType::KEYW_SWITCH, TokenType::KEYW_SWITCH},
        {"symbol", TokenType::LITERAL_IDENT, TokenType::KEYW_SYMBOL},
    }};

    static constexpr std::array<const KeywordString, 6> KEYWORDS_T = {{
        {"this", TokenType::KEYW_THIS, TokenType::KEYW_THIS},
        {"throw", TokenType::KEYW_THROW, TokenType::KEYW_THROW},
        {"true", TokenType::LITERAL_TRUE, TokenType::LITERAL_TRUE},
        {"try", TokenType::KEYW_TRY, TokenType::KEYW_TRY},
        {"type", TokenType::LITERAL_IDENT, TokenType::KEYW_TYPE},
        {"typeof", TokenType::KEYW_TYPEOF, TokenType::KEYW_TYPEOF},
    }};

    static constexpr std::array<const KeywordString, 3> KEYWORDS_U = {{
        {"undefined", TokenType::LITERAL_IDENT, TokenType::KEYW_UNDEFINED},
        {"unique", TokenType::LITERAL_IDENT, TokenType::KEYW_UNIQUE},
        {"unknown", TokenType::LITERAL_IDENT, TokenType::KEYW_UNKNOWN},
    }};

    static constexpr std::array<const KeywordString, 2> KEYWORDS_V = {{
        {"var", TokenType::KEYW_VAR, TokenType::KEYW_VAR},
        {"void", TokenType::KEYW_VOID, TokenType::KEYW_VOID},
    }};

    static constexpr std::array<const KeywordString, 2> KEYWORDS_W = {{
        {"while", TokenType::KEYW_WHILE, TokenType::KEYW_WHILE},
        {"with", TokenType::KEYW_WITH, TokenType::KEYW_WITH},
    }};

    static constexpr std::array<const KeywordString, 1> KEYWORDS_Y = {{
        {"yield", TokenType::KEYW_YIELD, TokenType::KEYW_YIELD},
    }};
};

} // namespace panda::es2panda::lexer
