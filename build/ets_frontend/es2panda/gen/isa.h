/**
 * Copyright (c) 2021-2022 Huawei Device Co., Ltd.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Autogenerated file -- DO NOT EDIT!

#ifndef ES2PANDA_COMPILER_GEN_IR_ISA_H
#define ES2PANDA_COMPILER_GEN_IR_ISA_H

#include <ir/irnode.h>
#include <gen/formats.h>
#include <assembly-ins.h>

namespace panda::es2panda::compiler {

class Label : public IRNode {
public:
    explicit Label(const ir::AstNode* node, std::string id) : IRNode(node), id_(std::move(id)) {}

    static constexpr std::string_view PREFIX = "LABEL_";

    Formats GetFormats() const override
    {
        return Span<const Format>(nullptr, nullptr);
    }

    const std::string &Id() const
    {
        return id_;
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        return 0;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        return 0;
    }

    void Transform(pandasm::Ins *ins) const override
    {
        ins->opcode = pandasm::Opcode::INVALID;
        ins->set_label = true;
        ins->label = id_;
    }

    ICSlot SetIcSlot(IcSizeType currentSlot) override
    {
        return 0;
    }

private:
    std::string id_;
};

class Ldundefined : public IRNode
{
public:
    explicit Ldundefined(const ir::AstNode* node) : IRNode(node) {}

    Formats GetFormats() const override {
        return Span<const Format>(LDUNDEFINED_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        return 0;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        return 0;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::LDUNDEFINED;
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        return 0;
    }


};

class Ldnull : public IRNode
{
public:
    explicit Ldnull(const ir::AstNode* node) : IRNode(node) {}

    Formats GetFormats() const override {
        return Span<const Format>(LDNULL_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        return 0;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        return 0;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::LDNULL;
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        return 0;
    }


};

class Ldtrue : public IRNode
{
public:
    explicit Ldtrue(const ir::AstNode* node) : IRNode(node) {}

    Formats GetFormats() const override {
        return Span<const Format>(LDTRUE_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        return 0;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        return 0;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::LDTRUE;
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        return 0;
    }


};

class Ldfalse : public IRNode
{
public:
    explicit Ldfalse(const ir::AstNode* node) : IRNode(node) {}

    Formats GetFormats() const override {
        return Span<const Format>(LDFALSE_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        return 0;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        return 0;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::LDFALSE;
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        return 0;
    }


};

class Createemptyobject : public IRNode
{
public:
    explicit Createemptyobject(const ir::AstNode* node) : IRNode(node) {}

    Formats GetFormats() const override {
        return Span<const Format>(CREATEEMPTYOBJECT_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        return 0;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        return 0;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::CREATEEMPTYOBJECT;
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        return 0;
    }


};

class Createemptyarray : public IRNode
{
public:
    explicit Createemptyarray(const ir::AstNode* node, int64_t imm) : IRNode(node), imm_(imm) {}

    Formats GetFormats() const override {
        return Span<const Format>(CREATEEMPTYARRAY_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        return 0;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        return 0;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::CREATEEMPTYARRAY;
        ins->imms.reserve(1);
        ins->imms.emplace_back(imm_);
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        constexpr static ICSlot invalid = 0xFF;
        if (slot <= 0xFF) {
            if ((slot + 1) > 0xFF) {
                imm_ = 0x100;
                return 1 + (0x100 - slot);
            }

            imm_ = slot;
            return 1;
        }

        if (slot > 0xFF && slot <= 0xFFFF) {
            imm_ = slot;
            return 1;
        }

        imm_ = invalid;
        return 0;
    }


private:
    int64_t imm_;
};

class Createarraywithbuffer : public IRNode
{
public:
    explicit Createarraywithbuffer(const ir::AstNode* node, int64_t imm, util::StringView stringId_0) : IRNode(node), imm_(imm), stringId_0_(stringId_0) {}

    Formats GetFormats() const override {
        return Span<const Format>(CREATEARRAYWITHBUFFER_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        return 0;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        return 0;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::CREATEARRAYWITHBUFFER;
        ins->imms.reserve(1);
        ins->ids.reserve(1);
        ins->imms.emplace_back(imm_);
        ins->ids.emplace_back(stringId_0_.Mutf8());
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        constexpr static ICSlot invalid = 0xFF;
        if (slot <= 0xFF) {
            if ((slot + 1) > 0xFF) {
                imm_ = 0x100;
                return 1 + (0x100 - slot);
            }

            imm_ = slot;
            return 1;
        }

        if (slot > 0xFF && slot <= 0xFFFF) {
            imm_ = slot;
            return 1;
        }

        imm_ = invalid;
        return 0;
    }


private:
    int64_t imm_;
    util::StringView stringId_0_;
};

class Createobjectwithbuffer : public IRNode
{
public:
    explicit Createobjectwithbuffer(const ir::AstNode* node, int64_t imm, util::StringView stringId_0) : IRNode(node), imm_(imm), stringId_0_(stringId_0) {}

    Formats GetFormats() const override {
        return Span<const Format>(CREATEOBJECTWITHBUFFER_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        return 0;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        return 0;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::CREATEOBJECTWITHBUFFER;
        ins->imms.reserve(1);
        ins->ids.reserve(1);
        ins->imms.emplace_back(imm_);
        ins->ids.emplace_back(stringId_0_.Mutf8());
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        constexpr static ICSlot invalid = 0xFF;
        if (slot <= 0xFF) {
            if ((slot + 1) > 0xFF) {
                imm_ = 0x100;
                return 1 + (0x100 - slot);
            }

            imm_ = slot;
            return 1;
        }

        if (slot > 0xFF && slot <= 0xFFFF) {
            imm_ = slot;
            return 1;
        }

        imm_ = invalid;
        return 0;
    }


private:
    int64_t imm_;
    util::StringView stringId_0_;
};

class Newobjrange : public IRNode
{
public:
    explicit Newobjrange(const ir::AstNode* node, int64_t imm1, int64_t imm2, VReg v) : IRNode(node), imm1_(imm1), imm2_(imm2), v_(v) {}

    Formats GetFormats() const override {
        return Span<const Format>(NEWOBJRANGE_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        (*regs)[0] = &v_;
        return 1;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        (*regs)[0] = &v_;
        return 1;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::NEWOBJRANGE;
        ins->regs.reserve(1);
        ins->imms.reserve(2);
        ins->regs.emplace_back(v_);
        ins->imms.emplace_back(imm1_);
        ins->imms.emplace_back(imm2_);
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        constexpr static ICSlot invalid = 0xFF;
        if (slot <= 0xFF) {
            if ((slot + 2) > 0xFF) {
                imm1_ = 0x100;
                return 2 + (0x100 - slot);
            }

            imm1_ = slot;
            return 2;
        }

        if (slot > 0xFF && slot <= 0xFFFF) {
            imm1_ = slot;
            return 2;
        }

        imm1_ = invalid;
        return 0;
    }

    bool IsRangeInst() const override
    {
        return true;
    }

    int64_t RangeRegsCount() override
    {
        return imm2_;
    }

private:
    int64_t imm1_;
    int64_t imm2_;
    VReg v_;
};

class Newlexenv : public IRNode
{
public:
    explicit Newlexenv(const ir::AstNode* node, int64_t imm) : IRNode(node), imm_(imm) {}

    Formats GetFormats() const override {
        return Span<const Format>(NEWLEXENV_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        return 0;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        return 0;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::NEWLEXENV;
        ins->imms.reserve(1);
        ins->imms.emplace_back(imm_);
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        return 0;
    }


private:
    int64_t imm_;
};

class Add2 : public IRNode
{
public:
    explicit Add2(const ir::AstNode* node, int64_t imm, VReg v) : IRNode(node), imm_(imm), v_(v) {}

    Formats GetFormats() const override {
        return Span<const Format>(ADD2_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        (*regs)[0] = &v_;
        return 1;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        (*regs)[0] = &v_;
        return 1;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::ADD2;
        ins->regs.reserve(1);
        ins->imms.reserve(1);
        ins->regs.emplace_back(v_);
        ins->imms.emplace_back(imm_);
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        constexpr static ICSlot invalid = 0xFF;
        if (slot < 0xFF) {
            if ((slot + 1) > 0xFF) {
                imm_ = invalid;
                return 0;
            }

            imm_ = slot;
            return 1;
        }

        imm_ = invalid;
        return 0;
    }


private:
    int64_t imm_;
    VReg v_;
};

class Sub2 : public IRNode
{
public:
    explicit Sub2(const ir::AstNode* node, int64_t imm, VReg v) : IRNode(node), imm_(imm), v_(v) {}

    Formats GetFormats() const override {
        return Span<const Format>(SUB2_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        (*regs)[0] = &v_;
        return 1;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        (*regs)[0] = &v_;
        return 1;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::SUB2;
        ins->regs.reserve(1);
        ins->imms.reserve(1);
        ins->regs.emplace_back(v_);
        ins->imms.emplace_back(imm_);
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        constexpr static ICSlot invalid = 0xFF;
        if (slot < 0xFF) {
            if ((slot + 1) > 0xFF) {
                imm_ = invalid;
                return 0;
            }

            imm_ = slot;
            return 1;
        }

        imm_ = invalid;
        return 0;
    }


private:
    int64_t imm_;
    VReg v_;
};

class Mul2 : public IRNode
{
public:
    explicit Mul2(const ir::AstNode* node, int64_t imm, VReg v) : IRNode(node), imm_(imm), v_(v) {}

    Formats GetFormats() const override {
        return Span<const Format>(MUL2_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        (*regs)[0] = &v_;
        return 1;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        (*regs)[0] = &v_;
        return 1;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::MUL2;
        ins->regs.reserve(1);
        ins->imms.reserve(1);
        ins->regs.emplace_back(v_);
        ins->imms.emplace_back(imm_);
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        constexpr static ICSlot invalid = 0xFF;
        if (slot < 0xFF) {
            if ((slot + 1) > 0xFF) {
                imm_ = invalid;
                return 0;
            }

            imm_ = slot;
            return 1;
        }

        imm_ = invalid;
        return 0;
    }


private:
    int64_t imm_;
    VReg v_;
};

class Div2 : public IRNode
{
public:
    explicit Div2(const ir::AstNode* node, int64_t imm, VReg v) : IRNode(node), imm_(imm), v_(v) {}

    Formats GetFormats() const override {
        return Span<const Format>(DIV2_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        (*regs)[0] = &v_;
        return 1;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        (*regs)[0] = &v_;
        return 1;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::DIV2;
        ins->regs.reserve(1);
        ins->imms.reserve(1);
        ins->regs.emplace_back(v_);
        ins->imms.emplace_back(imm_);
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        constexpr static ICSlot invalid = 0xFF;
        if (slot < 0xFF) {
            if ((slot + 1) > 0xFF) {
                imm_ = invalid;
                return 0;
            }

            imm_ = slot;
            return 1;
        }

        imm_ = invalid;
        return 0;
    }


private:
    int64_t imm_;
    VReg v_;
};

class Mod2 : public IRNode
{
public:
    explicit Mod2(const ir::AstNode* node, int64_t imm, VReg v) : IRNode(node), imm_(imm), v_(v) {}

    Formats GetFormats() const override {
        return Span<const Format>(MOD2_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        (*regs)[0] = &v_;
        return 1;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        (*regs)[0] = &v_;
        return 1;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::MOD2;
        ins->regs.reserve(1);
        ins->imms.reserve(1);
        ins->regs.emplace_back(v_);
        ins->imms.emplace_back(imm_);
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        constexpr static ICSlot invalid = 0xFF;
        if (slot < 0xFF) {
            if ((slot + 1) > 0xFF) {
                imm_ = invalid;
                return 0;
            }

            imm_ = slot;
            return 1;
        }

        imm_ = invalid;
        return 0;
    }


private:
    int64_t imm_;
    VReg v_;
};

class Eq : public IRNode
{
public:
    explicit Eq(const ir::AstNode* node, int64_t imm, VReg v) : IRNode(node), imm_(imm), v_(v) {}

    Formats GetFormats() const override {
        return Span<const Format>(EQ_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        (*regs)[0] = &v_;
        return 1;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        (*regs)[0] = &v_;
        return 1;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::EQ;
        ins->regs.reserve(1);
        ins->imms.reserve(1);
        ins->regs.emplace_back(v_);
        ins->imms.emplace_back(imm_);
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        constexpr static ICSlot invalid = 0xFF;
        if (slot < 0xFF) {
            if ((slot + 1) > 0xFF) {
                imm_ = invalid;
                return 0;
            }

            imm_ = slot;
            return 1;
        }

        imm_ = invalid;
        return 0;
    }


private:
    int64_t imm_;
    VReg v_;
};

class Noteq : public IRNode
{
public:
    explicit Noteq(const ir::AstNode* node, int64_t imm, VReg v) : IRNode(node), imm_(imm), v_(v) {}

    Formats GetFormats() const override {
        return Span<const Format>(NOTEQ_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        (*regs)[0] = &v_;
        return 1;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        (*regs)[0] = &v_;
        return 1;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::NOTEQ;
        ins->regs.reserve(1);
        ins->imms.reserve(1);
        ins->regs.emplace_back(v_);
        ins->imms.emplace_back(imm_);
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        constexpr static ICSlot invalid = 0xFF;
        if (slot < 0xFF) {
            if ((slot + 1) > 0xFF) {
                imm_ = invalid;
                return 0;
            }

            imm_ = slot;
            return 1;
        }

        imm_ = invalid;
        return 0;
    }


private:
    int64_t imm_;
    VReg v_;
};

class Less : public IRNode
{
public:
    explicit Less(const ir::AstNode* node, int64_t imm, VReg v) : IRNode(node), imm_(imm), v_(v) {}

    Formats GetFormats() const override {
        return Span<const Format>(LESS_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        (*regs)[0] = &v_;
        return 1;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        (*regs)[0] = &v_;
        return 1;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::LESS;
        ins->regs.reserve(1);
        ins->imms.reserve(1);
        ins->regs.emplace_back(v_);
        ins->imms.emplace_back(imm_);
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        constexpr static ICSlot invalid = 0xFF;
        if (slot < 0xFF) {
            if ((slot + 1) > 0xFF) {
                imm_ = invalid;
                return 0;
            }

            imm_ = slot;
            return 1;
        }

        imm_ = invalid;
        return 0;
    }


private:
    int64_t imm_;
    VReg v_;
};

class Lesseq : public IRNode
{
public:
    explicit Lesseq(const ir::AstNode* node, int64_t imm, VReg v) : IRNode(node), imm_(imm), v_(v) {}

    Formats GetFormats() const override {
        return Span<const Format>(LESSEQ_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        (*regs)[0] = &v_;
        return 1;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        (*regs)[0] = &v_;
        return 1;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::LESSEQ;
        ins->regs.reserve(1);
        ins->imms.reserve(1);
        ins->regs.emplace_back(v_);
        ins->imms.emplace_back(imm_);
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        constexpr static ICSlot invalid = 0xFF;
        if (slot < 0xFF) {
            if ((slot + 1) > 0xFF) {
                imm_ = invalid;
                return 0;
            }

            imm_ = slot;
            return 1;
        }

        imm_ = invalid;
        return 0;
    }


private:
    int64_t imm_;
    VReg v_;
};

class Greater : public IRNode
{
public:
    explicit Greater(const ir::AstNode* node, int64_t imm, VReg v) : IRNode(node), imm_(imm), v_(v) {}

    Formats GetFormats() const override {
        return Span<const Format>(GREATER_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        (*regs)[0] = &v_;
        return 1;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        (*regs)[0] = &v_;
        return 1;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::GREATER;
        ins->regs.reserve(1);
        ins->imms.reserve(1);
        ins->regs.emplace_back(v_);
        ins->imms.emplace_back(imm_);
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        constexpr static ICSlot invalid = 0xFF;
        if (slot < 0xFF) {
            if ((slot + 1) > 0xFF) {
                imm_ = invalid;
                return 0;
            }

            imm_ = slot;
            return 1;
        }

        imm_ = invalid;
        return 0;
    }


private:
    int64_t imm_;
    VReg v_;
};

class Greatereq : public IRNode
{
public:
    explicit Greatereq(const ir::AstNode* node, int64_t imm, VReg v) : IRNode(node), imm_(imm), v_(v) {}

    Formats GetFormats() const override {
        return Span<const Format>(GREATEREQ_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        (*regs)[0] = &v_;
        return 1;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        (*regs)[0] = &v_;
        return 1;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::GREATEREQ;
        ins->regs.reserve(1);
        ins->imms.reserve(1);
        ins->regs.emplace_back(v_);
        ins->imms.emplace_back(imm_);
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        constexpr static ICSlot invalid = 0xFF;
        if (slot < 0xFF) {
            if ((slot + 1) > 0xFF) {
                imm_ = invalid;
                return 0;
            }

            imm_ = slot;
            return 1;
        }

        imm_ = invalid;
        return 0;
    }


private:
    int64_t imm_;
    VReg v_;
};

class Shl2 : public IRNode
{
public:
    explicit Shl2(const ir::AstNode* node, int64_t imm, VReg v) : IRNode(node), imm_(imm), v_(v) {}

    Formats GetFormats() const override {
        return Span<const Format>(SHL2_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        (*regs)[0] = &v_;
        return 1;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        (*regs)[0] = &v_;
        return 1;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::SHL2;
        ins->regs.reserve(1);
        ins->imms.reserve(1);
        ins->regs.emplace_back(v_);
        ins->imms.emplace_back(imm_);
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        constexpr static ICSlot invalid = 0xFF;
        if (slot < 0xFF) {
            if ((slot + 1) > 0xFF) {
                imm_ = invalid;
                return 0;
            }

            imm_ = slot;
            return 1;
        }

        imm_ = invalid;
        return 0;
    }


private:
    int64_t imm_;
    VReg v_;
};

class Shr2 : public IRNode
{
public:
    explicit Shr2(const ir::AstNode* node, int64_t imm, VReg v) : IRNode(node), imm_(imm), v_(v) {}

    Formats GetFormats() const override {
        return Span<const Format>(SHR2_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        (*regs)[0] = &v_;
        return 1;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        (*regs)[0] = &v_;
        return 1;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::SHR2;
        ins->regs.reserve(1);
        ins->imms.reserve(1);
        ins->regs.emplace_back(v_);
        ins->imms.emplace_back(imm_);
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        constexpr static ICSlot invalid = 0xFF;
        if (slot < 0xFF) {
            if ((slot + 1) > 0xFF) {
                imm_ = invalid;
                return 0;
            }

            imm_ = slot;
            return 1;
        }

        imm_ = invalid;
        return 0;
    }


private:
    int64_t imm_;
    VReg v_;
};

class Ashr2 : public IRNode
{
public:
    explicit Ashr2(const ir::AstNode* node, int64_t imm, VReg v) : IRNode(node), imm_(imm), v_(v) {}

    Formats GetFormats() const override {
        return Span<const Format>(ASHR2_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        (*regs)[0] = &v_;
        return 1;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        (*regs)[0] = &v_;
        return 1;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::ASHR2;
        ins->regs.reserve(1);
        ins->imms.reserve(1);
        ins->regs.emplace_back(v_);
        ins->imms.emplace_back(imm_);
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        constexpr static ICSlot invalid = 0xFF;
        if (slot < 0xFF) {
            if ((slot + 1) > 0xFF) {
                imm_ = invalid;
                return 0;
            }

            imm_ = slot;
            return 1;
        }

        imm_ = invalid;
        return 0;
    }


private:
    int64_t imm_;
    VReg v_;
};

class And2 : public IRNode
{
public:
    explicit And2(const ir::AstNode* node, int64_t imm, VReg v) : IRNode(node), imm_(imm), v_(v) {}

    Formats GetFormats() const override {
        return Span<const Format>(AND2_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        (*regs)[0] = &v_;
        return 1;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        (*regs)[0] = &v_;
        return 1;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::AND2;
        ins->regs.reserve(1);
        ins->imms.reserve(1);
        ins->regs.emplace_back(v_);
        ins->imms.emplace_back(imm_);
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        constexpr static ICSlot invalid = 0xFF;
        if (slot < 0xFF) {
            if ((slot + 1) > 0xFF) {
                imm_ = invalid;
                return 0;
            }

            imm_ = slot;
            return 1;
        }

        imm_ = invalid;
        return 0;
    }


private:
    int64_t imm_;
    VReg v_;
};

class Or2 : public IRNode
{
public:
    explicit Or2(const ir::AstNode* node, int64_t imm, VReg v) : IRNode(node), imm_(imm), v_(v) {}

    Formats GetFormats() const override {
        return Span<const Format>(OR2_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        (*regs)[0] = &v_;
        return 1;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        (*regs)[0] = &v_;
        return 1;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::OR2;
        ins->regs.reserve(1);
        ins->imms.reserve(1);
        ins->regs.emplace_back(v_);
        ins->imms.emplace_back(imm_);
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        constexpr static ICSlot invalid = 0xFF;
        if (slot < 0xFF) {
            if ((slot + 1) > 0xFF) {
                imm_ = invalid;
                return 0;
            }

            imm_ = slot;
            return 1;
        }

        imm_ = invalid;
        return 0;
    }


private:
    int64_t imm_;
    VReg v_;
};

class Xor2 : public IRNode
{
public:
    explicit Xor2(const ir::AstNode* node, int64_t imm, VReg v) : IRNode(node), imm_(imm), v_(v) {}

    Formats GetFormats() const override {
        return Span<const Format>(XOR2_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        (*regs)[0] = &v_;
        return 1;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        (*regs)[0] = &v_;
        return 1;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::XOR2;
        ins->regs.reserve(1);
        ins->imms.reserve(1);
        ins->regs.emplace_back(v_);
        ins->imms.emplace_back(imm_);
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        constexpr static ICSlot invalid = 0xFF;
        if (slot < 0xFF) {
            if ((slot + 1) > 0xFF) {
                imm_ = invalid;
                return 0;
            }

            imm_ = slot;
            return 1;
        }

        imm_ = invalid;
        return 0;
    }


private:
    int64_t imm_;
    VReg v_;
};

class Exp : public IRNode
{
public:
    explicit Exp(const ir::AstNode* node, int64_t imm, VReg v) : IRNode(node), imm_(imm), v_(v) {}

    Formats GetFormats() const override {
        return Span<const Format>(EXP_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        (*regs)[0] = &v_;
        return 1;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        (*regs)[0] = &v_;
        return 1;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::EXP;
        ins->regs.reserve(1);
        ins->imms.reserve(1);
        ins->regs.emplace_back(v_);
        ins->imms.emplace_back(imm_);
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        constexpr static ICSlot invalid = 0xFF;
        if (slot < 0xFF) {
            if ((slot + 1) > 0xFF) {
                imm_ = invalid;
                return 0;
            }

            imm_ = slot;
            return 1;
        }

        imm_ = invalid;
        return 0;
    }


private:
    int64_t imm_;
    VReg v_;
};

class Typeof : public IRNode
{
public:
    explicit Typeof(const ir::AstNode* node, int64_t imm) : IRNode(node), imm_(imm) {}

    Formats GetFormats() const override {
        return Span<const Format>(TYPEOF_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        return 0;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        return 0;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::TYPEOF;
        ins->imms.reserve(1);
        ins->imms.emplace_back(imm_);
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        constexpr static ICSlot invalid = 0xFF;
        if (slot <= 0xFF) {
            if ((slot + 2) > 0xFF) {
                imm_ = 0x100;
                return 2 + (0x100 - slot);
            }

            imm_ = slot;
            return 2;
        }

        if (slot > 0xFF && slot <= 0xFFFF) {
            imm_ = slot;
            return 2;
        }

        imm_ = invalid;
        return 0;
    }


private:
    int64_t imm_;
};

class Tonumber : public IRNode
{
public:
    explicit Tonumber(const ir::AstNode* node, int64_t imm) : IRNode(node), imm_(imm) {}

    Formats GetFormats() const override {
        return Span<const Format>(TONUMBER_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        return 0;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        return 0;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::TONUMBER;
        ins->imms.reserve(1);
        ins->imms.emplace_back(imm_);
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        constexpr static ICSlot invalid = 0xFF;
        if (slot < 0xFF) {
            if ((slot + 1) > 0xFF) {
                imm_ = invalid;
                return 0;
            }

            imm_ = slot;
            return 1;
        }

        imm_ = invalid;
        return 0;
    }


private:
    int64_t imm_;
};

class Tonumeric : public IRNode
{
public:
    explicit Tonumeric(const ir::AstNode* node, int64_t imm) : IRNode(node), imm_(imm) {}

    Formats GetFormats() const override {
        return Span<const Format>(TONUMERIC_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        return 0;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        return 0;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::TONUMERIC;
        ins->imms.reserve(1);
        ins->imms.emplace_back(imm_);
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        constexpr static ICSlot invalid = 0xFF;
        if (slot < 0xFF) {
            if ((slot + 1) > 0xFF) {
                imm_ = invalid;
                return 0;
            }

            imm_ = slot;
            return 1;
        }

        imm_ = invalid;
        return 0;
    }


private:
    int64_t imm_;
};

class Neg : public IRNode
{
public:
    explicit Neg(const ir::AstNode* node, int64_t imm) : IRNode(node), imm_(imm) {}

    Formats GetFormats() const override {
        return Span<const Format>(NEG_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        return 0;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        return 0;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::NEG;
        ins->imms.reserve(1);
        ins->imms.emplace_back(imm_);
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        constexpr static ICSlot invalid = 0xFF;
        if (slot < 0xFF) {
            if ((slot + 1) > 0xFF) {
                imm_ = invalid;
                return 0;
            }

            imm_ = slot;
            return 1;
        }

        imm_ = invalid;
        return 0;
    }


private:
    int64_t imm_;
};

class Not : public IRNode
{
public:
    explicit Not(const ir::AstNode* node, int64_t imm) : IRNode(node), imm_(imm) {}

    Formats GetFormats() const override {
        return Span<const Format>(NOT_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        return 0;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        return 0;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::NOT;
        ins->imms.reserve(1);
        ins->imms.emplace_back(imm_);
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        constexpr static ICSlot invalid = 0xFF;
        if (slot < 0xFF) {
            if ((slot + 1) > 0xFF) {
                imm_ = invalid;
                return 0;
            }

            imm_ = slot;
            return 1;
        }

        imm_ = invalid;
        return 0;
    }


private:
    int64_t imm_;
};

class Inc : public IRNode
{
public:
    explicit Inc(const ir::AstNode* node, int64_t imm) : IRNode(node), imm_(imm) {}

    Formats GetFormats() const override {
        return Span<const Format>(INC_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        return 0;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        return 0;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::INC;
        ins->imms.reserve(1);
        ins->imms.emplace_back(imm_);
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        constexpr static ICSlot invalid = 0xFF;
        if (slot < 0xFF) {
            if ((slot + 1) > 0xFF) {
                imm_ = invalid;
                return 0;
            }

            imm_ = slot;
            return 1;
        }

        imm_ = invalid;
        return 0;
    }


private:
    int64_t imm_;
};

class Dec : public IRNode
{
public:
    explicit Dec(const ir::AstNode* node, int64_t imm) : IRNode(node), imm_(imm) {}

    Formats GetFormats() const override {
        return Span<const Format>(DEC_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        return 0;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        return 0;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::DEC;
        ins->imms.reserve(1);
        ins->imms.emplace_back(imm_);
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        constexpr static ICSlot invalid = 0xFF;
        if (slot < 0xFF) {
            if ((slot + 1) > 0xFF) {
                imm_ = invalid;
                return 0;
            }

            imm_ = slot;
            return 1;
        }

        imm_ = invalid;
        return 0;
    }


private:
    int64_t imm_;
};

class Istrue : public IRNode
{
public:
    explicit Istrue(const ir::AstNode* node) : IRNode(node) {}

    Formats GetFormats() const override {
        return Span<const Format>(ISTRUE_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        return 0;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        return 0;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::ISTRUE;
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        return 0;
    }


};

class Isfalse : public IRNode
{
public:
    explicit Isfalse(const ir::AstNode* node) : IRNode(node) {}

    Formats GetFormats() const override {
        return Span<const Format>(ISFALSE_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        return 0;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        return 0;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::ISFALSE;
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        return 0;
    }


};

class Isin : public IRNode
{
public:
    explicit Isin(const ir::AstNode* node, int64_t imm, VReg v) : IRNode(node), imm_(imm), v_(v) {}

    Formats GetFormats() const override {
        return Span<const Format>(ISIN_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        (*regs)[0] = &v_;
        return 1;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        (*regs)[0] = &v_;
        return 1;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::ISIN;
        ins->regs.reserve(1);
        ins->imms.reserve(1);
        ins->regs.emplace_back(v_);
        ins->imms.emplace_back(imm_);
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        constexpr static ICSlot invalid = 0xFF;
        if (slot < 0xFF) {
            if ((slot + 1) > 0xFF) {
                imm_ = invalid;
                return 0;
            }

            imm_ = slot;
            return 1;
        }

        imm_ = invalid;
        return 0;
    }


private:
    int64_t imm_;
    VReg v_;
};

class Instanceof : public IRNode
{
public:
    explicit Instanceof(const ir::AstNode* node, int64_t imm, VReg v) : IRNode(node), imm_(imm), v_(v) {}

    Formats GetFormats() const override {
        return Span<const Format>(INSTANCEOF_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        (*regs)[0] = &v_;
        return 1;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        (*regs)[0] = &v_;
        return 1;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::INSTANCEOF;
        ins->regs.reserve(1);
        ins->imms.reserve(1);
        ins->regs.emplace_back(v_);
        ins->imms.emplace_back(imm_);
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        constexpr static ICSlot invalid = 0xFF;
        if (slot < 0xFF) {
            if ((slot + 2) > 0xFF) {
                imm_ = invalid;
                return 0;
            }

            imm_ = slot;
            return 2;
        }

        imm_ = invalid;
        return 0;
    }


private:
    int64_t imm_;
    VReg v_;
};

class Strictnoteq : public IRNode
{
public:
    explicit Strictnoteq(const ir::AstNode* node, int64_t imm, VReg v) : IRNode(node), imm_(imm), v_(v) {}

    Formats GetFormats() const override {
        return Span<const Format>(STRICTNOTEQ_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        (*regs)[0] = &v_;
        return 1;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        (*regs)[0] = &v_;
        return 1;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::STRICTNOTEQ;
        ins->regs.reserve(1);
        ins->imms.reserve(1);
        ins->regs.emplace_back(v_);
        ins->imms.emplace_back(imm_);
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        constexpr static ICSlot invalid = 0xFF;
        if (slot < 0xFF) {
            if ((slot + 1) > 0xFF) {
                imm_ = invalid;
                return 0;
            }

            imm_ = slot;
            return 1;
        }

        imm_ = invalid;
        return 0;
    }


private:
    int64_t imm_;
    VReg v_;
};

class Stricteq : public IRNode
{
public:
    explicit Stricteq(const ir::AstNode* node, int64_t imm, VReg v) : IRNode(node), imm_(imm), v_(v) {}

    Formats GetFormats() const override {
        return Span<const Format>(STRICTEQ_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        (*regs)[0] = &v_;
        return 1;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        (*regs)[0] = &v_;
        return 1;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::STRICTEQ;
        ins->regs.reserve(1);
        ins->imms.reserve(1);
        ins->regs.emplace_back(v_);
        ins->imms.emplace_back(imm_);
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        constexpr static ICSlot invalid = 0xFF;
        if (slot < 0xFF) {
            if ((slot + 1) > 0xFF) {
                imm_ = invalid;
                return 0;
            }

            imm_ = slot;
            return 1;
        }

        imm_ = invalid;
        return 0;
    }


private:
    int64_t imm_;
    VReg v_;
};

class Callarg0 : public IRNode
{
public:
    explicit Callarg0(const ir::AstNode* node, int64_t imm) : IRNode(node), imm_(imm) {}

    Formats GetFormats() const override {
        return Span<const Format>(CALLARG0_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        return 0;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        return 0;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::CALLARG0;
        ins->imms.reserve(1);
        ins->imms.emplace_back(imm_);
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        constexpr static ICSlot invalid = 0xFF;
        if (slot < 0xFF) {
            if ((slot + 2) > 0xFF) {
                imm_ = invalid;
                return 0;
            }

            imm_ = slot;
            return 2;
        }

        imm_ = invalid;
        return 0;
    }


private:
    int64_t imm_;
};

class Callarg1 : public IRNode
{
public:
    explicit Callarg1(const ir::AstNode* node, int64_t imm, VReg v) : IRNode(node), imm_(imm), v_(v) {}

    Formats GetFormats() const override {
        return Span<const Format>(CALLARG1_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        (*regs)[0] = &v_;
        return 1;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        (*regs)[0] = &v_;
        return 1;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::CALLARG1;
        ins->regs.reserve(1);
        ins->imms.reserve(1);
        ins->regs.emplace_back(v_);
        ins->imms.emplace_back(imm_);
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        constexpr static ICSlot invalid = 0xFF;
        if (slot < 0xFF) {
            if ((slot + 2) > 0xFF) {
                imm_ = invalid;
                return 0;
            }

            imm_ = slot;
            return 2;
        }

        imm_ = invalid;
        return 0;
    }


private:
    int64_t imm_;
    VReg v_;
};

class Callargs2 : public IRNode
{
public:
    explicit Callargs2(const ir::AstNode* node, int64_t imm, VReg v1, VReg v2) : IRNode(node), imm_(imm), v1_(v1), v2_(v2) {}

    Formats GetFormats() const override {
        return Span<const Format>(CALLARGS2_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        (*regs)[0] = &v1_;
        (*regs)[1] = &v2_;
        return 2;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        (*regs)[0] = &v1_;
        (*regs)[1] = &v2_;
        return 2;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::CALLARGS2;
        ins->regs.reserve(2);
        ins->imms.reserve(1);
        ins->regs.emplace_back(v1_);
        ins->regs.emplace_back(v2_);
        ins->imms.emplace_back(imm_);
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        constexpr static ICSlot invalid = 0xFF;
        if (slot < 0xFF) {
            if ((slot + 2) > 0xFF) {
                imm_ = invalid;
                return 0;
            }

            imm_ = slot;
            return 2;
        }

        imm_ = invalid;
        return 0;
    }


private:
    int64_t imm_;
    VReg v1_;
    VReg v2_;
};

class Callargs3 : public IRNode
{
public:
    explicit Callargs3(const ir::AstNode* node, int64_t imm, VReg v1, VReg v2, VReg v3) : IRNode(node), imm_(imm), v1_(v1), v2_(v2), v3_(v3) {}

    Formats GetFormats() const override {
        return Span<const Format>(CALLARGS3_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        (*regs)[0] = &v1_;
        (*regs)[1] = &v2_;
        (*regs)[2] = &v3_;
        return 3;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        (*regs)[0] = &v1_;
        (*regs)[1] = &v2_;
        (*regs)[2] = &v3_;
        return 3;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::CALLARGS3;
        ins->regs.reserve(3);
        ins->imms.reserve(1);
        ins->regs.emplace_back(v1_);
        ins->regs.emplace_back(v2_);
        ins->regs.emplace_back(v3_);
        ins->imms.emplace_back(imm_);
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        constexpr static ICSlot invalid = 0xFF;
        if (slot < 0xFF) {
            if ((slot + 2) > 0xFF) {
                imm_ = invalid;
                return 0;
            }

            imm_ = slot;
            return 2;
        }

        imm_ = invalid;
        return 0;
    }


private:
    int64_t imm_;
    VReg v1_;
    VReg v2_;
    VReg v3_;
};

class Callthis0 : public IRNode
{
public:
    explicit Callthis0(const ir::AstNode* node, int64_t imm, VReg v) : IRNode(node), imm_(imm), v_(v) {}

    Formats GetFormats() const override {
        return Span<const Format>(CALLTHIS0_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        (*regs)[0] = &v_;
        return 1;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        (*regs)[0] = &v_;
        return 1;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::CALLTHIS0;
        ins->regs.reserve(1);
        ins->imms.reserve(1);
        ins->regs.emplace_back(v_);
        ins->imms.emplace_back(imm_);
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        constexpr static ICSlot invalid = 0xFF;
        if (slot < 0xFF) {
            if ((slot + 2) > 0xFF) {
                imm_ = invalid;
                return 0;
            }

            imm_ = slot;
            return 2;
        }

        imm_ = invalid;
        return 0;
    }


private:
    int64_t imm_;
    VReg v_;
};

class Callthis1 : public IRNode
{
public:
    explicit Callthis1(const ir::AstNode* node, int64_t imm, VReg v1, VReg v2) : IRNode(node), imm_(imm), v1_(v1), v2_(v2) {}

    Formats GetFormats() const override {
        return Span<const Format>(CALLTHIS1_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        (*regs)[0] = &v1_;
        (*regs)[1] = &v2_;
        return 2;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        (*regs)[0] = &v1_;
        (*regs)[1] = &v2_;
        return 2;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::CALLTHIS1;
        ins->regs.reserve(2);
        ins->imms.reserve(1);
        ins->regs.emplace_back(v1_);
        ins->regs.emplace_back(v2_);
        ins->imms.emplace_back(imm_);
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        constexpr static ICSlot invalid = 0xFF;
        if (slot < 0xFF) {
            if ((slot + 2) > 0xFF) {
                imm_ = invalid;
                return 0;
            }

            imm_ = slot;
            return 2;
        }

        imm_ = invalid;
        return 0;
    }


private:
    int64_t imm_;
    VReg v1_;
    VReg v2_;
};

class Callthis2 : public IRNode
{
public:
    explicit Callthis2(const ir::AstNode* node, int64_t imm, VReg v1, VReg v2, VReg v3) : IRNode(node), imm_(imm), v1_(v1), v2_(v2), v3_(v3) {}

    Formats GetFormats() const override {
        return Span<const Format>(CALLTHIS2_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        (*regs)[0] = &v1_;
        (*regs)[1] = &v2_;
        (*regs)[2] = &v3_;
        return 3;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        (*regs)[0] = &v1_;
        (*regs)[1] = &v2_;
        (*regs)[2] = &v3_;
        return 3;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::CALLTHIS2;
        ins->regs.reserve(3);
        ins->imms.reserve(1);
        ins->regs.emplace_back(v1_);
        ins->regs.emplace_back(v2_);
        ins->regs.emplace_back(v3_);
        ins->imms.emplace_back(imm_);
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        constexpr static ICSlot invalid = 0xFF;
        if (slot < 0xFF) {
            if ((slot + 2) > 0xFF) {
                imm_ = invalid;
                return 0;
            }

            imm_ = slot;
            return 2;
        }

        imm_ = invalid;
        return 0;
    }


private:
    int64_t imm_;
    VReg v1_;
    VReg v2_;
    VReg v3_;
};

class Callthis3 : public IRNode
{
public:
    explicit Callthis3(const ir::AstNode* node, int64_t imm, VReg v1, VReg v2, VReg v3, VReg v4) : IRNode(node), imm_(imm), v1_(v1), v2_(v2), v3_(v3), v4_(v4) {}

    Formats GetFormats() const override {
        return Span<const Format>(CALLTHIS3_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        (*regs)[0] = &v1_;
        (*regs)[1] = &v2_;
        (*regs)[2] = &v3_;
        (*regs)[3] = &v4_;
        return 4;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        (*regs)[0] = &v1_;
        (*regs)[1] = &v2_;
        (*regs)[2] = &v3_;
        (*regs)[3] = &v4_;
        return 4;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::CALLTHIS3;
        ins->regs.reserve(4);
        ins->imms.reserve(1);
        ins->regs.emplace_back(v1_);
        ins->regs.emplace_back(v2_);
        ins->regs.emplace_back(v3_);
        ins->regs.emplace_back(v4_);
        ins->imms.emplace_back(imm_);
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        constexpr static ICSlot invalid = 0xFF;
        if (slot < 0xFF) {
            if ((slot + 2) > 0xFF) {
                imm_ = invalid;
                return 0;
            }

            imm_ = slot;
            return 2;
        }

        imm_ = invalid;
        return 0;
    }


private:
    int64_t imm_;
    VReg v1_;
    VReg v2_;
    VReg v3_;
    VReg v4_;
};

class Callthisrange : public IRNode
{
public:
    explicit Callthisrange(const ir::AstNode* node, int64_t imm1, int64_t imm2, VReg v) : IRNode(node), imm1_(imm1), imm2_(imm2), v_(v) {}

    Formats GetFormats() const override {
        return Span<const Format>(CALLTHISRANGE_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        (*regs)[0] = &v_;
        return 1;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        (*regs)[0] = &v_;
        return 1;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::CALLTHISRANGE;
        ins->regs.reserve(1);
        ins->imms.reserve(2);
        ins->regs.emplace_back(v_);
        ins->imms.emplace_back(imm1_);
        ins->imms.emplace_back(imm2_);
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        constexpr static ICSlot invalid = 0xFF;
        if (slot < 0xFF) {
            if ((slot + 2) > 0xFF) {
                imm1_ = invalid;
                return 0;
            }

            imm1_ = slot;
            return 2;
        }

        imm1_ = invalid;
        return 0;
    }

    bool IsRangeInst() const override
    {
        return true;
    }

    int64_t RangeRegsCount() override
    {
        return imm2_ + 1;
    }

private:
    int64_t imm1_;
    int64_t imm2_;
    VReg v_;
};

class Supercallthisrange : public IRNode
{
public:
    explicit Supercallthisrange(const ir::AstNode* node, int64_t imm1, int64_t imm2, VReg v) : IRNode(node), imm1_(imm1), imm2_(imm2), v_(v) {}

    Formats GetFormats() const override {
        return Span<const Format>(SUPERCALLTHISRANGE_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        (*regs)[0] = &v_;
        return 1;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        (*regs)[0] = &v_;
        return 1;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::SUPERCALLTHISRANGE;
        ins->regs.reserve(1);
        ins->imms.reserve(2);
        ins->regs.emplace_back(v_);
        ins->imms.emplace_back(imm1_);
        ins->imms.emplace_back(imm2_);
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        constexpr static ICSlot invalid = 0xFF;
        if (slot < 0xFF) {
            if ((slot + 2) > 0xFF) {
                imm1_ = invalid;
                return 0;
            }

            imm1_ = slot;
            return 2;
        }

        imm1_ = invalid;
        return 0;
    }

    bool IsRangeInst() const override
    {
        return true;
    }

    int64_t RangeRegsCount() override
    {
        return imm2_;
    }

private:
    int64_t imm1_;
    int64_t imm2_;
    VReg v_;
};

class Definefunc : public IRNode
{
public:
    explicit Definefunc(const ir::AstNode* node, int64_t imm1, util::StringView stringId_0, int64_t imm2) : IRNode(node), imm1_(imm1), stringId_0_(stringId_0), imm2_(imm2) {}

    Formats GetFormats() const override {
        return Span<const Format>(DEFINEFUNC_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        return 0;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        return 0;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::DEFINEFUNC;
        ins->imms.reserve(2);
        ins->ids.reserve(1);
        ins->imms.emplace_back(imm1_);
        ins->imms.emplace_back(imm2_);
        ins->ids.emplace_back(stringId_0_.Mutf8());
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        constexpr static ICSlot invalid = 0xFF;
        if (slot <= 0xFF) {
            if ((slot + 1) > 0xFF) {
                imm1_ = 0x100;
                return 1 + (0x100 - slot);
            }

            imm1_ = slot;
            return 1;
        }

        if (slot > 0xFF && slot <= 0xFFFF) {
            imm1_ = slot;
            return 1;
        }

        imm1_ = invalid;
        return 0;
    }


private:
    int64_t imm1_;
    util::StringView stringId_0_;
    int64_t imm2_;
};

class Definemethod : public IRNode
{
public:
    explicit Definemethod(const ir::AstNode* node, int64_t imm1, util::StringView stringId_0, int64_t imm2) : IRNode(node), imm1_(imm1), stringId_0_(stringId_0), imm2_(imm2) {}

    Formats GetFormats() const override {
        return Span<const Format>(DEFINEMETHOD_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        return 0;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        return 0;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::DEFINEMETHOD;
        ins->imms.reserve(2);
        ins->ids.reserve(1);
        ins->imms.emplace_back(imm1_);
        ins->imms.emplace_back(imm2_);
        ins->ids.emplace_back(stringId_0_.Mutf8());
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        constexpr static ICSlot invalid = 0xFF;
        if (slot <= 0xFF) {
            if ((slot + 1) > 0xFF) {
                imm1_ = 0x100;
                return 1 + (0x100 - slot);
            }

            imm1_ = slot;
            return 1;
        }

        if (slot > 0xFF && slot <= 0xFFFF) {
            imm1_ = slot;
            return 1;
        }

        imm1_ = invalid;
        return 0;
    }


private:
    int64_t imm1_;
    util::StringView stringId_0_;
    int64_t imm2_;
};

class Defineclasswithbuffer : public IRNode
{
public:
    explicit Defineclasswithbuffer(const ir::AstNode* node, int64_t imm1, util::StringView stringId_0, util::StringView stringId_1, int64_t imm2, VReg v) : IRNode(node), imm1_(imm1), stringId_0_(stringId_0), stringId_1_(stringId_1), imm2_(imm2), v_(v) {}

    Formats GetFormats() const override {
        return Span<const Format>(DEFINECLASSWITHBUFFER_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        (*regs)[0] = &v_;
        return 1;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        (*regs)[0] = &v_;
        return 1;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::DEFINECLASSWITHBUFFER;
        ins->regs.reserve(1);
        ins->imms.reserve(2);
        ins->ids.reserve(2);
        ins->regs.emplace_back(v_);
        ins->imms.emplace_back(imm1_);
        ins->imms.emplace_back(imm2_);
        ins->ids.emplace_back(stringId_0_.Mutf8());
        ins->ids.emplace_back(stringId_1_.Mutf8());
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        constexpr static ICSlot invalid = 0xFF;
        if (slot <= 0xFF) {
            if ((slot + 1) > 0xFF) {
                imm1_ = 0x100;
                return 1 + (0x100 - slot);
            }

            imm1_ = slot;
            return 1;
        }

        if (slot > 0xFF && slot <= 0xFFFF) {
            imm1_ = slot;
            return 1;
        }

        imm1_ = invalid;
        return 0;
    }


private:
    int64_t imm1_;
    util::StringView stringId_0_;
    util::StringView stringId_1_;
    int64_t imm2_;
    VReg v_;
};

class Getnextpropname : public IRNode
{
public:
    explicit Getnextpropname(const ir::AstNode* node, VReg v) : IRNode(node), v_(v) {}

    Formats GetFormats() const override {
        return Span<const Format>(GETNEXTPROPNAME_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        (*regs)[0] = &v_;
        return 1;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        (*regs)[0] = &v_;
        return 1;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::GETNEXTPROPNAME;
        ins->regs.reserve(1);
        ins->regs.emplace_back(v_);
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        return 0;
    }


private:
    VReg v_;
};

class Ldobjbyvalue : public IRNode
{
public:
    explicit Ldobjbyvalue(const ir::AstNode* node, int64_t imm, VReg v) : IRNode(node), imm_(imm), v_(v) {}

    Formats GetFormats() const override {
        return Span<const Format>(LDOBJBYVALUE_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        (*regs)[0] = &v_;
        return 1;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        (*regs)[0] = &v_;
        return 1;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::LDOBJBYVALUE;
        ins->regs.reserve(1);
        ins->imms.reserve(1);
        ins->regs.emplace_back(v_);
        ins->imms.emplace_back(imm_);
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        constexpr static ICSlot invalid = 0xFF;
        if (slot <= 0xFF) {
            if ((slot + 2) > 0xFF) {
                imm_ = 0x100;
                return 2 + (0x100 - slot);
            }

            imm_ = slot;
            return 2;
        }

        if (slot > 0xFF && slot <= 0xFFFF) {
            imm_ = slot;
            return 2;
        }

        imm_ = invalid;
        return 0;
    }


private:
    int64_t imm_;
    VReg v_;
};

class Stobjbyvalue : public IRNode
{
public:
    explicit Stobjbyvalue(const ir::AstNode* node, int64_t imm, VReg v1, VReg v2) : IRNode(node), imm_(imm), v1_(v1), v2_(v2) {}

    Formats GetFormats() const override {
        return Span<const Format>(STOBJBYVALUE_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        (*regs)[0] = &v1_;
        (*regs)[1] = &v2_;
        return 2;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        (*regs)[0] = &v1_;
        (*regs)[1] = &v2_;
        return 2;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::STOBJBYVALUE;
        ins->regs.reserve(2);
        ins->imms.reserve(1);
        ins->regs.emplace_back(v1_);
        ins->regs.emplace_back(v2_);
        ins->imms.emplace_back(imm_);
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        constexpr static ICSlot invalid = 0xFF;
        if (slot <= 0xFF) {
            if ((slot + 2) > 0xFF) {
                imm_ = 0x100;
                return 2 + (0x100 - slot);
            }

            imm_ = slot;
            return 2;
        }

        if (slot > 0xFF && slot <= 0xFFFF) {
            imm_ = slot;
            return 2;
        }

        imm_ = invalid;
        return 0;
    }


private:
    int64_t imm_;
    VReg v1_;
    VReg v2_;
};

class Ldsuperbyvalue : public IRNode
{
public:
    explicit Ldsuperbyvalue(const ir::AstNode* node, int64_t imm, VReg v) : IRNode(node), imm_(imm), v_(v) {}

    Formats GetFormats() const override {
        return Span<const Format>(LDSUPERBYVALUE_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        (*regs)[0] = &v_;
        return 1;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        (*regs)[0] = &v_;
        return 1;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::LDSUPERBYVALUE;
        ins->regs.reserve(1);
        ins->imms.reserve(1);
        ins->regs.emplace_back(v_);
        ins->imms.emplace_back(imm_);
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        constexpr static ICSlot invalid = 0xFF;
        if (slot <= 0xFF) {
            if ((slot + 2) > 0xFF) {
                imm_ = 0x100;
                return 2 + (0x100 - slot);
            }

            imm_ = slot;
            return 2;
        }

        if (slot > 0xFF && slot <= 0xFFFF) {
            imm_ = slot;
            return 2;
        }

        imm_ = invalid;
        return 0;
    }


private:
    int64_t imm_;
    VReg v_;
};

class Ldobjbyindex : public IRNode
{
public:
    explicit Ldobjbyindex(const ir::AstNode* node, int64_t imm1, int64_t imm2) : IRNode(node), imm1_(imm1), imm2_(imm2) {}

    Formats GetFormats() const override {
        return Span<const Format>(LDOBJBYINDEX_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        return 0;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        return 0;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::LDOBJBYINDEX;
        ins->imms.reserve(2);
        ins->imms.emplace_back(imm1_);
        ins->imms.emplace_back(imm2_);
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        constexpr static ICSlot invalid = 0xFF;
        if (slot <= 0xFF) {
            if ((slot + 2) > 0xFF) {
                imm1_ = 0x100;
                return 2 + (0x100 - slot);
            }

            imm1_ = slot;
            return 2;
        }

        if (slot > 0xFF && slot <= 0xFFFF) {
            imm1_ = slot;
            return 2;
        }

        imm1_ = invalid;
        return 0;
    }


private:
    int64_t imm1_;
    int64_t imm2_;
};

class Stobjbyindex : public IRNode
{
public:
    explicit Stobjbyindex(const ir::AstNode* node, int64_t imm1, VReg v, int64_t imm2) : IRNode(node), imm1_(imm1), v_(v), imm2_(imm2) {}

    Formats GetFormats() const override {
        return Span<const Format>(STOBJBYINDEX_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        (*regs)[0] = &v_;
        return 1;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        (*regs)[0] = &v_;
        return 1;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::STOBJBYINDEX;
        ins->regs.reserve(1);
        ins->imms.reserve(2);
        ins->regs.emplace_back(v_);
        ins->imms.emplace_back(imm1_);
        ins->imms.emplace_back(imm2_);
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        constexpr static ICSlot invalid = 0xFF;
        if (slot <= 0xFF) {
            if ((slot + 2) > 0xFF) {
                imm1_ = 0x100;
                return 2 + (0x100 - slot);
            }

            imm1_ = slot;
            return 2;
        }

        if (slot > 0xFF && slot <= 0xFFFF) {
            imm1_ = slot;
            return 2;
        }

        imm1_ = invalid;
        return 0;
    }


private:
    int64_t imm1_;
    VReg v_;
    int64_t imm2_;
};

class Ldlexvar : public IRNode
{
public:
    explicit Ldlexvar(const ir::AstNode* node, int64_t imm1, int64_t imm2) : IRNode(node), imm1_(imm1), imm2_(imm2) {}

    Formats GetFormats() const override {
        return Span<const Format>(LDLEXVAR_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        return 0;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        return 0;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::LDLEXVAR;
        ins->imms.reserve(2);
        ins->imms.emplace_back(imm1_);
        ins->imms.emplace_back(imm2_);
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        return 0;
    }


private:
    int64_t imm1_;
    int64_t imm2_;
};

class Stlexvar : public IRNode
{
public:
    explicit Stlexvar(const ir::AstNode* node, int64_t imm1, int64_t imm2) : IRNode(node), imm1_(imm1), imm2_(imm2) {}

    Formats GetFormats() const override {
        return Span<const Format>(STLEXVAR_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        return 0;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        return 0;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::STLEXVAR;
        ins->imms.reserve(2);
        ins->imms.emplace_back(imm1_);
        ins->imms.emplace_back(imm2_);
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        return 0;
    }


private:
    int64_t imm1_;
    int64_t imm2_;
};

class LdaStr : public IRNode
{
public:
    explicit LdaStr(const ir::AstNode* node, util::StringView stringId_0) : IRNode(node), stringId_0_(stringId_0) {}

    Formats GetFormats() const override {
        return Span<const Format>(LDA_STR_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        return 0;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        return 0;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::LDA_STR;
        ins->ids.reserve(1);
        ins->ids.emplace_back(stringId_0_.Mutf8());
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        return 0;
    }


private:
    util::StringView stringId_0_;
};

class Tryldglobalbyname : public IRNode
{
public:
    explicit Tryldglobalbyname(const ir::AstNode* node, int64_t imm, util::StringView stringId_0) : IRNode(node), imm_(imm), stringId_0_(stringId_0) {}

    Formats GetFormats() const override {
        return Span<const Format>(TRYLDGLOBALBYNAME_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        return 0;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        return 0;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::TRYLDGLOBALBYNAME;
        ins->imms.reserve(1);
        ins->ids.reserve(1);
        ins->imms.emplace_back(imm_);
        ins->ids.emplace_back(stringId_0_.Mutf8());
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        constexpr static ICSlot invalid = 0xFF;
        if (slot <= 0xFF) {
            if ((slot + 1) > 0xFF) {
                imm_ = 0x100;
                return 1 + (0x100 - slot);
            }

            imm_ = slot;
            return 1;
        }

        if (slot > 0xFF && slot <= 0xFFFF) {
            imm_ = slot;
            return 1;
        }

        imm_ = invalid;
        return 0;
    }


private:
    int64_t imm_;
    util::StringView stringId_0_;
};

class Trystglobalbyname : public IRNode
{
public:
    explicit Trystglobalbyname(const ir::AstNode* node, int64_t imm, util::StringView stringId_0) : IRNode(node), imm_(imm), stringId_0_(stringId_0) {}

    Formats GetFormats() const override {
        return Span<const Format>(TRYSTGLOBALBYNAME_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        return 0;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        return 0;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::TRYSTGLOBALBYNAME;
        ins->imms.reserve(1);
        ins->ids.reserve(1);
        ins->imms.emplace_back(imm_);
        ins->ids.emplace_back(stringId_0_.Mutf8());
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        constexpr static ICSlot invalid = 0xFF;
        if (slot <= 0xFF) {
            if ((slot + 1) > 0xFF) {
                imm_ = 0x100;
                return 1 + (0x100 - slot);
            }

            imm_ = slot;
            return 1;
        }

        if (slot > 0xFF && slot <= 0xFFFF) {
            imm_ = slot;
            return 1;
        }

        imm_ = invalid;
        return 0;
    }


private:
    int64_t imm_;
    util::StringView stringId_0_;
};

class Ldglobalvar : public IRNode
{
public:
    explicit Ldglobalvar(const ir::AstNode* node, int64_t imm, util::StringView stringId_0) : IRNode(node), imm_(imm), stringId_0_(stringId_0) {}

    Formats GetFormats() const override {
        return Span<const Format>(LDGLOBALVAR_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        return 0;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        return 0;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::LDGLOBALVAR;
        ins->imms.reserve(1);
        ins->ids.reserve(1);
        ins->imms.emplace_back(imm_);
        ins->ids.emplace_back(stringId_0_.Mutf8());
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        constexpr static ICSlot invalid = 0xFF;
        if (slot <= 0xFF) {
            if ((slot + 1) > 0xFF) {
                imm_ = 0x100;
                return 1 + (0x100 - slot);
            }

            imm_ = slot;
            return 1;
        }

        if (slot > 0xFF && slot <= 0xFFFF) {
            imm_ = slot;
            return 1;
        }

        imm_ = invalid;
        return 0;
    }


private:
    int64_t imm_;
    util::StringView stringId_0_;
};

class Ldobjbyname : public IRNode
{
public:
    explicit Ldobjbyname(const ir::AstNode* node, int64_t imm, util::StringView stringId_0) : IRNode(node), imm_(imm), stringId_0_(stringId_0) {}

    Formats GetFormats() const override {
        return Span<const Format>(LDOBJBYNAME_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        return 0;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        return 0;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::LDOBJBYNAME;
        ins->imms.reserve(1);
        ins->ids.reserve(1);
        ins->imms.emplace_back(imm_);
        ins->ids.emplace_back(stringId_0_.Mutf8());
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        constexpr static ICSlot invalid = 0xFF;
        if (slot <= 0xFF) {
            if ((slot + 2) > 0xFF) {
                imm_ = 0x100;
                return 2 + (0x100 - slot);
            }

            imm_ = slot;
            return 2;
        }

        if (slot > 0xFF && slot <= 0xFFFF) {
            imm_ = slot;
            return 2;
        }

        imm_ = invalid;
        return 0;
    }


private:
    int64_t imm_;
    util::StringView stringId_0_;
};

class Stobjbyname : public IRNode
{
public:
    explicit Stobjbyname(const ir::AstNode* node, int64_t imm, util::StringView stringId_0, VReg v) : IRNode(node), imm_(imm), stringId_0_(stringId_0), v_(v) {}

    Formats GetFormats() const override {
        return Span<const Format>(STOBJBYNAME_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        (*regs)[0] = &v_;
        return 1;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        (*regs)[0] = &v_;
        return 1;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::STOBJBYNAME;
        ins->regs.reserve(1);
        ins->imms.reserve(1);
        ins->ids.reserve(1);
        ins->regs.emplace_back(v_);
        ins->imms.emplace_back(imm_);
        ins->ids.emplace_back(stringId_0_.Mutf8());
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        constexpr static ICSlot invalid = 0xFF;
        if (slot <= 0xFF) {
            if ((slot + 2) > 0xFF) {
                imm_ = 0x100;
                return 2 + (0x100 - slot);
            }

            imm_ = slot;
            return 2;
        }

        if (slot > 0xFF && slot <= 0xFFFF) {
            imm_ = slot;
            return 2;
        }

        imm_ = invalid;
        return 0;
    }


private:
    int64_t imm_;
    util::StringView stringId_0_;
    VReg v_;
};

class Mov : public IRNode
{
public:
    explicit Mov(const ir::AstNode* node, VReg v1, VReg v2) : IRNode(node), v1_(v1), v2_(v2) {}

    Formats GetFormats() const override {
        return Span<const Format>(MOV_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        (*regs)[0] = &v1_;
        (*regs)[1] = &v2_;
        return 2;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        (*regs)[0] = &v1_;
        (*regs)[1] = &v2_;
        return 2;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::MOV;
        ins->regs.reserve(2);
        ins->regs.emplace_back(v1_);
        ins->regs.emplace_back(v2_);
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        return 0;
    }


private:
    VReg v1_;
    VReg v2_;
};

class Ldsuperbyname : public IRNode
{
public:
    explicit Ldsuperbyname(const ir::AstNode* node, int64_t imm, util::StringView stringId_0) : IRNode(node), imm_(imm), stringId_0_(stringId_0) {}

    Formats GetFormats() const override {
        return Span<const Format>(LDSUPERBYNAME_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        return 0;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        return 0;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::LDSUPERBYNAME;
        ins->imms.reserve(1);
        ins->ids.reserve(1);
        ins->imms.emplace_back(imm_);
        ins->ids.emplace_back(stringId_0_.Mutf8());
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        constexpr static ICSlot invalid = 0xFF;
        if (slot <= 0xFF) {
            if ((slot + 2) > 0xFF) {
                imm_ = 0x100;
                return 2 + (0x100 - slot);
            }

            imm_ = slot;
            return 2;
        }

        if (slot > 0xFF && slot <= 0xFFFF) {
            imm_ = slot;
            return 2;
        }

        imm_ = invalid;
        return 0;
    }


private:
    int64_t imm_;
    util::StringView stringId_0_;
};

class Stconsttoglobalrecord : public IRNode
{
public:
    explicit Stconsttoglobalrecord(const ir::AstNode* node, int64_t imm, util::StringView stringId_0) : IRNode(node), imm_(imm), stringId_0_(stringId_0) {}

    Formats GetFormats() const override {
        return Span<const Format>(STCONSTTOGLOBALRECORD_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        return 0;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        return 0;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::STCONSTTOGLOBALRECORD;
        ins->imms.reserve(1);
        ins->ids.reserve(1);
        ins->imms.emplace_back(imm_);
        ins->ids.emplace_back(stringId_0_.Mutf8());
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        constexpr static ICSlot invalid = 0xFF;
        if (slot <= 0xFF) {
            if ((slot + 1) > 0xFF) {
                imm_ = 0x100;
                return 1 + (0x100 - slot);
            }

            imm_ = slot;
            return 1;
        }

        if (slot > 0xFF && slot <= 0xFFFF) {
            imm_ = slot;
            return 1;
        }

        imm_ = invalid;
        return 0;
    }


private:
    int64_t imm_;
    util::StringView stringId_0_;
};

class Sttoglobalrecord : public IRNode
{
public:
    explicit Sttoglobalrecord(const ir::AstNode* node, int64_t imm, util::StringView stringId_0) : IRNode(node), imm_(imm), stringId_0_(stringId_0) {}

    Formats GetFormats() const override {
        return Span<const Format>(STTOGLOBALRECORD_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        return 0;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        return 0;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::STTOGLOBALRECORD;
        ins->imms.reserve(1);
        ins->ids.reserve(1);
        ins->imms.emplace_back(imm_);
        ins->ids.emplace_back(stringId_0_.Mutf8());
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        constexpr static ICSlot invalid = 0xFF;
        if (slot <= 0xFF) {
            if ((slot + 1) > 0xFF) {
                imm_ = 0x100;
                return 1 + (0x100 - slot);
            }

            imm_ = slot;
            return 1;
        }

        if (slot > 0xFF && slot <= 0xFFFF) {
            imm_ = slot;
            return 1;
        }

        imm_ = invalid;
        return 0;
    }


private:
    int64_t imm_;
    util::StringView stringId_0_;
};

class Ldthisbyname : public IRNode
{
public:
    explicit Ldthisbyname(const ir::AstNode* node, int64_t imm, util::StringView stringId_0) : IRNode(node), imm_(imm), stringId_0_(stringId_0) {}

    Formats GetFormats() const override {
        return Span<const Format>(LDTHISBYNAME_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        return 0;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        return 0;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::LDTHISBYNAME;
        ins->imms.reserve(1);
        ins->ids.reserve(1);
        ins->imms.emplace_back(imm_);
        ins->ids.emplace_back(stringId_0_.Mutf8());
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        constexpr static ICSlot invalid = 0xFF;
        if (slot <= 0xFF) {
            if ((slot + 2) > 0xFF) {
                imm_ = 0x100;
                return 2 + (0x100 - slot);
            }

            imm_ = slot;
            return 2;
        }

        if (slot > 0xFF && slot <= 0xFFFF) {
            imm_ = slot;
            return 2;
        }

        imm_ = invalid;
        return 0;
    }


private:
    int64_t imm_;
    util::StringView stringId_0_;
};

class Stthisbyname : public IRNode
{
public:
    explicit Stthisbyname(const ir::AstNode* node, int64_t imm, util::StringView stringId_0) : IRNode(node), imm_(imm), stringId_0_(stringId_0) {}

    Formats GetFormats() const override {
        return Span<const Format>(STTHISBYNAME_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        return 0;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        return 0;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::STTHISBYNAME;
        ins->imms.reserve(1);
        ins->ids.reserve(1);
        ins->imms.emplace_back(imm_);
        ins->ids.emplace_back(stringId_0_.Mutf8());
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        constexpr static ICSlot invalid = 0xFF;
        if (slot <= 0xFF) {
            if ((slot + 2) > 0xFF) {
                imm_ = 0x100;
                return 2 + (0x100 - slot);
            }

            imm_ = slot;
            return 2;
        }

        if (slot > 0xFF && slot <= 0xFFFF) {
            imm_ = slot;
            return 2;
        }

        imm_ = invalid;
        return 0;
    }


private:
    int64_t imm_;
    util::StringView stringId_0_;
};

class Ldthisbyvalue : public IRNode
{
public:
    explicit Ldthisbyvalue(const ir::AstNode* node, int64_t imm) : IRNode(node), imm_(imm) {}

    Formats GetFormats() const override {
        return Span<const Format>(LDTHISBYVALUE_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        return 0;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        return 0;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::LDTHISBYVALUE;
        ins->imms.reserve(1);
        ins->imms.emplace_back(imm_);
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        constexpr static ICSlot invalid = 0xFF;
        if (slot <= 0xFF) {
            if ((slot + 2) > 0xFF) {
                imm_ = 0x100;
                return 2 + (0x100 - slot);
            }

            imm_ = slot;
            return 2;
        }

        if (slot > 0xFF && slot <= 0xFFFF) {
            imm_ = slot;
            return 2;
        }

        imm_ = invalid;
        return 0;
    }


private:
    int64_t imm_;
};

class Stthisbyvalue : public IRNode
{
public:
    explicit Stthisbyvalue(const ir::AstNode* node, int64_t imm, VReg v) : IRNode(node), imm_(imm), v_(v) {}

    Formats GetFormats() const override {
        return Span<const Format>(STTHISBYVALUE_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        (*regs)[0] = &v_;
        return 1;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        (*regs)[0] = &v_;
        return 1;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::STTHISBYVALUE;
        ins->regs.reserve(1);
        ins->imms.reserve(1);
        ins->regs.emplace_back(v_);
        ins->imms.emplace_back(imm_);
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        constexpr static ICSlot invalid = 0xFF;
        if (slot <= 0xFF) {
            if ((slot + 2) > 0xFF) {
                imm_ = 0x100;
                return 2 + (0x100 - slot);
            }

            imm_ = slot;
            return 2;
        }

        if (slot > 0xFF && slot <= 0xFFFF) {
            imm_ = slot;
            return 2;
        }

        imm_ = invalid;
        return 0;
    }


private:
    int64_t imm_;
    VReg v_;
};

class Jmp : public IRNode
{
public:
    explicit Jmp(const ir::AstNode* node, Label* imm) : IRNode(node), imm_(imm) {}

    Formats GetFormats() const override {
        return Span<const Format>(JMP_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        return 0;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        return 0;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::JMP;
        ins->ids.reserve(1);
        ins->ids.emplace_back(imm_->Id());
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        return 0;
    }


private:
    Label* imm_;
};

class Jeqz : public IRNode
{
public:
    explicit Jeqz(const ir::AstNode* node, Label* imm) : IRNode(node), imm_(imm) {}

    Formats GetFormats() const override {
        return Span<const Format>(JEQZ_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        return 0;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        return 0;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::JEQZ;
        ins->ids.reserve(1);
        ins->ids.emplace_back(imm_->Id());
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        return 0;
    }


private:
    Label* imm_;
};

class Jnez : public IRNode
{
public:
    explicit Jnez(const ir::AstNode* node, Label* imm) : IRNode(node), imm_(imm) {}

    Formats GetFormats() const override {
        return Span<const Format>(JNEZ_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        return 0;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        return 0;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::JNEZ;
        ins->ids.reserve(1);
        ins->ids.emplace_back(imm_->Id());
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        return 0;
    }


private:
    Label* imm_;
};

class Jstricteqz : public IRNode
{
public:
    explicit Jstricteqz(const ir::AstNode* node, Label* imm) : IRNode(node), imm_(imm) {}

    Formats GetFormats() const override {
        return Span<const Format>(JSTRICTEQZ_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        return 0;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        return 0;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::JSTRICTEQZ;
        ins->ids.reserve(1);
        ins->ids.emplace_back(imm_->Id());
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        return 0;
    }


private:
    Label* imm_;
};

class Jnstricteqz : public IRNode
{
public:
    explicit Jnstricteqz(const ir::AstNode* node, Label* imm) : IRNode(node), imm_(imm) {}

    Formats GetFormats() const override {
        return Span<const Format>(JNSTRICTEQZ_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        return 0;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        return 0;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::JNSTRICTEQZ;
        ins->ids.reserve(1);
        ins->ids.emplace_back(imm_->Id());
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        return 0;
    }


private:
    Label* imm_;
};

class Jeqnull : public IRNode
{
public:
    explicit Jeqnull(const ir::AstNode* node, Label* imm) : IRNode(node), imm_(imm) {}

    Formats GetFormats() const override {
        return Span<const Format>(JEQNULL_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        return 0;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        return 0;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::JEQNULL;
        ins->ids.reserve(1);
        ins->ids.emplace_back(imm_->Id());
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        return 0;
    }


private:
    Label* imm_;
};

class Jnenull : public IRNode
{
public:
    explicit Jnenull(const ir::AstNode* node, Label* imm) : IRNode(node), imm_(imm) {}

    Formats GetFormats() const override {
        return Span<const Format>(JNENULL_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        return 0;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        return 0;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::JNENULL;
        ins->ids.reserve(1);
        ins->ids.emplace_back(imm_->Id());
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        return 0;
    }


private:
    Label* imm_;
};

class Jstricteqnull : public IRNode
{
public:
    explicit Jstricteqnull(const ir::AstNode* node, Label* imm) : IRNode(node), imm_(imm) {}

    Formats GetFormats() const override {
        return Span<const Format>(JSTRICTEQNULL_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        return 0;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        return 0;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::JSTRICTEQNULL;
        ins->ids.reserve(1);
        ins->ids.emplace_back(imm_->Id());
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        return 0;
    }


private:
    Label* imm_;
};

class Jnstricteqnull : public IRNode
{
public:
    explicit Jnstricteqnull(const ir::AstNode* node, Label* imm) : IRNode(node), imm_(imm) {}

    Formats GetFormats() const override {
        return Span<const Format>(JNSTRICTEQNULL_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        return 0;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        return 0;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::JNSTRICTEQNULL;
        ins->ids.reserve(1);
        ins->ids.emplace_back(imm_->Id());
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        return 0;
    }


private:
    Label* imm_;
};

class Jequndefined : public IRNode
{
public:
    explicit Jequndefined(const ir::AstNode* node, Label* imm) : IRNode(node), imm_(imm) {}

    Formats GetFormats() const override {
        return Span<const Format>(JEQUNDEFINED_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        return 0;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        return 0;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::JEQUNDEFINED;
        ins->ids.reserve(1);
        ins->ids.emplace_back(imm_->Id());
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        return 0;
    }


private:
    Label* imm_;
};

class Jneundefined : public IRNode
{
public:
    explicit Jneundefined(const ir::AstNode* node, Label* imm) : IRNode(node), imm_(imm) {}

    Formats GetFormats() const override {
        return Span<const Format>(JNEUNDEFINED_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        return 0;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        return 0;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::JNEUNDEFINED;
        ins->ids.reserve(1);
        ins->ids.emplace_back(imm_->Id());
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        return 0;
    }


private:
    Label* imm_;
};

class Jstrictequndefined : public IRNode
{
public:
    explicit Jstrictequndefined(const ir::AstNode* node, Label* imm) : IRNode(node), imm_(imm) {}

    Formats GetFormats() const override {
        return Span<const Format>(JSTRICTEQUNDEFINED_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        return 0;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        return 0;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::JSTRICTEQUNDEFINED;
        ins->ids.reserve(1);
        ins->ids.emplace_back(imm_->Id());
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        return 0;
    }


private:
    Label* imm_;
};

class Jnstrictequndefined : public IRNode
{
public:
    explicit Jnstrictequndefined(const ir::AstNode* node, Label* imm) : IRNode(node), imm_(imm) {}

    Formats GetFormats() const override {
        return Span<const Format>(JNSTRICTEQUNDEFINED_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        return 0;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        return 0;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::JNSTRICTEQUNDEFINED;
        ins->ids.reserve(1);
        ins->ids.emplace_back(imm_->Id());
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        return 0;
    }


private:
    Label* imm_;
};

class Jeq : public IRNode
{
public:
    explicit Jeq(const ir::AstNode* node, VReg v, Label* imm) : IRNode(node), v_(v), imm_(imm) {}

    Formats GetFormats() const override {
        return Span<const Format>(JEQ_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        (*regs)[0] = &v_;
        return 1;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        (*regs)[0] = &v_;
        return 1;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::JEQ;
        ins->regs.reserve(1);
        ins->ids.reserve(1);
        ins->regs.emplace_back(v_);
        ins->ids.emplace_back(imm_->Id());
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        return 0;
    }


private:
    VReg v_;
    Label* imm_;
};

class Jne : public IRNode
{
public:
    explicit Jne(const ir::AstNode* node, VReg v, Label* imm) : IRNode(node), v_(v), imm_(imm) {}

    Formats GetFormats() const override {
        return Span<const Format>(JNE_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        (*regs)[0] = &v_;
        return 1;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        (*regs)[0] = &v_;
        return 1;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::JNE;
        ins->regs.reserve(1);
        ins->ids.reserve(1);
        ins->regs.emplace_back(v_);
        ins->ids.emplace_back(imm_->Id());
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        return 0;
    }


private:
    VReg v_;
    Label* imm_;
};

class Jstricteq : public IRNode
{
public:
    explicit Jstricteq(const ir::AstNode* node, VReg v, Label* imm) : IRNode(node), v_(v), imm_(imm) {}

    Formats GetFormats() const override {
        return Span<const Format>(JSTRICTEQ_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        (*regs)[0] = &v_;
        return 1;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        (*regs)[0] = &v_;
        return 1;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::JSTRICTEQ;
        ins->regs.reserve(1);
        ins->ids.reserve(1);
        ins->regs.emplace_back(v_);
        ins->ids.emplace_back(imm_->Id());
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        return 0;
    }


private:
    VReg v_;
    Label* imm_;
};

class Jnstricteq : public IRNode
{
public:
    explicit Jnstricteq(const ir::AstNode* node, VReg v, Label* imm) : IRNode(node), v_(v), imm_(imm) {}

    Formats GetFormats() const override {
        return Span<const Format>(JNSTRICTEQ_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        (*regs)[0] = &v_;
        return 1;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        (*regs)[0] = &v_;
        return 1;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::JNSTRICTEQ;
        ins->regs.reserve(1);
        ins->ids.reserve(1);
        ins->regs.emplace_back(v_);
        ins->ids.emplace_back(imm_->Id());
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        return 0;
    }


private:
    VReg v_;
    Label* imm_;
};

class Lda : public IRNode
{
public:
    explicit Lda(const ir::AstNode* node, VReg v) : IRNode(node), v_(v) {}

    Formats GetFormats() const override {
        return Span<const Format>(LDA_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        (*regs)[0] = &v_;
        return 1;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        (*regs)[0] = &v_;
        return 1;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::LDA;
        ins->regs.reserve(1);
        ins->regs.emplace_back(v_);
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        return 0;
    }


private:
    VReg v_;
};

class Sta : public IRNode
{
public:
    explicit Sta(const ir::AstNode* node, VReg v) : IRNode(node), v_(v) {}

    Formats GetFormats() const override {
        return Span<const Format>(STA_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        (*regs)[0] = &v_;
        return 1;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        (*regs)[0] = &v_;
        return 1;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::STA;
        ins->regs.reserve(1);
        ins->regs.emplace_back(v_);
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        return 0;
    }


private:
    VReg v_;
};

class Ldai : public IRNode
{
public:
    explicit Ldai(const ir::AstNode* node, int64_t imm) : IRNode(node), imm_(imm) {}

    Formats GetFormats() const override {
        return Span<const Format>(LDAI_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        return 0;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        return 0;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::LDAI;
        ins->imms.reserve(1);
        ins->imms.emplace_back(imm_);
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        return 0;
    }


private:
    int64_t imm_;
};

class Fldai : public IRNode
{
public:
    explicit Fldai(const ir::AstNode* node, double imm) : IRNode(node), imm_(imm) {}

    Formats GetFormats() const override {
        return Span<const Format>(FLDAI_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        return 0;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        return 0;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::FLDAI;
        ins->imms.reserve(1);
        ins->imms.emplace_back(imm_);
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        return 0;
    }


private:
    double imm_;
};

class Return : public IRNode
{
public:
    explicit Return(const ir::AstNode* node) : IRNode(node) {}

    Formats GetFormats() const override {
        return Span<const Format>(RETURN_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        return 0;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        return 0;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::RETURN;
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        return 0;
    }


};

class Returnundefined : public IRNode
{
public:
    explicit Returnundefined(const ir::AstNode* node) : IRNode(node) {}

    Formats GetFormats() const override {
        return Span<const Format>(RETURNUNDEFINED_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        return 0;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        return 0;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::RETURNUNDEFINED;
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        return 0;
    }


};

class Getpropiterator : public IRNode
{
public:
    explicit Getpropiterator(const ir::AstNode* node) : IRNode(node) {}

    Formats GetFormats() const override {
        return Span<const Format>(GETPROPITERATOR_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        return 0;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        return 0;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::GETPROPITERATOR;
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        return 0;
    }


};

class Getiterator : public IRNode
{
public:
    explicit Getiterator(const ir::AstNode* node, int64_t imm) : IRNode(node), imm_(imm) {}

    Formats GetFormats() const override {
        return Span<const Format>(GETITERATOR_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        return 0;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        return 0;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::GETITERATOR;
        ins->imms.reserve(1);
        ins->imms.emplace_back(imm_);
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        constexpr static ICSlot invalid = 0xFF;
        if (slot <= 0xFF) {
            if ((slot + 2) > 0xFF) {
                imm_ = 0x100;
                return 2 + (0x100 - slot);
            }

            imm_ = slot;
            return 2;
        }

        if (slot > 0xFF && slot <= 0xFFFF) {
            imm_ = slot;
            return 2;
        }

        imm_ = invalid;
        return 0;
    }


private:
    int64_t imm_;
};

class Closeiterator : public IRNode
{
public:
    explicit Closeiterator(const ir::AstNode* node, int64_t imm, VReg v) : IRNode(node), imm_(imm), v_(v) {}

    Formats GetFormats() const override {
        return Span<const Format>(CLOSEITERATOR_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        (*regs)[0] = &v_;
        return 1;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        (*regs)[0] = &v_;
        return 1;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::CLOSEITERATOR;
        ins->regs.reserve(1);
        ins->imms.reserve(1);
        ins->regs.emplace_back(v_);
        ins->imms.emplace_back(imm_);
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        constexpr static ICSlot invalid = 0xFF;
        if (slot <= 0xFF) {
            if ((slot + 2) > 0xFF) {
                imm_ = 0x100;
                return 2 + (0x100 - slot);
            }

            imm_ = slot;
            return 2;
        }

        if (slot > 0xFF && slot <= 0xFFFF) {
            imm_ = slot;
            return 2;
        }

        imm_ = invalid;
        return 0;
    }


private:
    int64_t imm_;
    VReg v_;
};

class Poplexenv : public IRNode
{
public:
    explicit Poplexenv(const ir::AstNode* node) : IRNode(node) {}

    Formats GetFormats() const override {
        return Span<const Format>(POPLEXENV_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        return 0;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        return 0;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::POPLEXENV;
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        return 0;
    }


};

class Ldnan : public IRNode
{
public:
    explicit Ldnan(const ir::AstNode* node) : IRNode(node) {}

    Formats GetFormats() const override {
        return Span<const Format>(LDNAN_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        return 0;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        return 0;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::LDNAN;
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        return 0;
    }


};

class Ldinfinity : public IRNode
{
public:
    explicit Ldinfinity(const ir::AstNode* node) : IRNode(node) {}

    Formats GetFormats() const override {
        return Span<const Format>(LDINFINITY_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        return 0;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        return 0;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::LDINFINITY;
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        return 0;
    }


};

class Getunmappedargs : public IRNode
{
public:
    explicit Getunmappedargs(const ir::AstNode* node) : IRNode(node) {}

    Formats GetFormats() const override {
        return Span<const Format>(GETUNMAPPEDARGS_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        return 0;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        return 0;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::GETUNMAPPEDARGS;
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        return 0;
    }


};

class Ldglobal : public IRNode
{
public:
    explicit Ldglobal(const ir::AstNode* node) : IRNode(node) {}

    Formats GetFormats() const override {
        return Span<const Format>(LDGLOBAL_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        return 0;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        return 0;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::LDGLOBAL;
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        return 0;
    }


};

class Ldnewtarget : public IRNode
{
public:
    explicit Ldnewtarget(const ir::AstNode* node) : IRNode(node) {}

    Formats GetFormats() const override {
        return Span<const Format>(LDNEWTARGET_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        return 0;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        return 0;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::LDNEWTARGET;
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        return 0;
    }


};

class Ldthis : public IRNode
{
public:
    explicit Ldthis(const ir::AstNode* node) : IRNode(node) {}

    Formats GetFormats() const override {
        return Span<const Format>(LDTHIS_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        return 0;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        return 0;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::LDTHIS;
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        return 0;
    }


};

class Ldhole : public IRNode
{
public:
    explicit Ldhole(const ir::AstNode* node) : IRNode(node) {}

    Formats GetFormats() const override {
        return Span<const Format>(LDHOLE_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        return 0;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        return 0;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::LDHOLE;
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        return 0;
    }


};

class Createregexpwithliteral : public IRNode
{
public:
    explicit Createregexpwithliteral(const ir::AstNode* node, int64_t imm1, util::StringView stringId_0, int64_t imm2) : IRNode(node), imm1_(imm1), stringId_0_(stringId_0), imm2_(imm2) {}

    Formats GetFormats() const override {
        return Span<const Format>(CREATEREGEXPWITHLITERAL_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        return 0;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        return 0;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::CREATEREGEXPWITHLITERAL;
        ins->imms.reserve(2);
        ins->ids.reserve(1);
        ins->imms.emplace_back(imm1_);
        ins->imms.emplace_back(imm2_);
        ins->ids.emplace_back(stringId_0_.Mutf8());
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        constexpr static ICSlot invalid = 0xFF;
        if (slot <= 0xFF) {
            if ((slot + 2) > 0xFF) {
                imm1_ = 0x100;
                return 2 + (0x100 - slot);
            }

            imm1_ = slot;
            return 2;
        }

        if (slot > 0xFF && slot <= 0xFFFF) {
            imm1_ = slot;
            return 2;
        }

        imm1_ = invalid;
        return 0;
    }


private:
    int64_t imm1_;
    util::StringView stringId_0_;
    int64_t imm2_;
};

class Callrange : public IRNode
{
public:
    explicit Callrange(const ir::AstNode* node, int64_t imm1, int64_t imm2, VReg v) : IRNode(node), imm1_(imm1), imm2_(imm2), v_(v) {}

    Formats GetFormats() const override {
        return Span<const Format>(CALLRANGE_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        (*regs)[0] = &v_;
        return 1;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        (*regs)[0] = &v_;
        return 1;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::CALLRANGE;
        ins->regs.reserve(1);
        ins->imms.reserve(2);
        ins->regs.emplace_back(v_);
        ins->imms.emplace_back(imm1_);
        ins->imms.emplace_back(imm2_);
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        constexpr static ICSlot invalid = 0xFF;
        if (slot < 0xFF) {
            if ((slot + 2) > 0xFF) {
                imm1_ = invalid;
                return 0;
            }

            imm1_ = slot;
            return 2;
        }

        imm1_ = invalid;
        return 0;
    }

    bool IsRangeInst() const override
    {
        return true;
    }

    int64_t RangeRegsCount() override
    {
        return imm2_;
    }

private:
    int64_t imm1_;
    int64_t imm2_;
    VReg v_;
};

class Gettemplateobject : public IRNode
{
public:
    explicit Gettemplateobject(const ir::AstNode* node, int64_t imm) : IRNode(node), imm_(imm) {}

    Formats GetFormats() const override {
        return Span<const Format>(GETTEMPLATEOBJECT_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        return 0;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        return 0;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::GETTEMPLATEOBJECT;
        ins->imms.reserve(1);
        ins->imms.emplace_back(imm_);
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        constexpr static ICSlot invalid = 0xFF;
        if (slot <= 0xFF) {
            if ((slot + 1) > 0xFF) {
                imm_ = 0x100;
                return 1 + (0x100 - slot);
            }

            imm_ = slot;
            return 1;
        }

        if (slot > 0xFF && slot <= 0xFFFF) {
            imm_ = slot;
            return 1;
        }

        imm_ = invalid;
        return 0;
    }


private:
    int64_t imm_;
};

class Setobjectwithproto : public IRNode
{
public:
    explicit Setobjectwithproto(const ir::AstNode* node, int64_t imm, VReg v) : IRNode(node), imm_(imm), v_(v) {}

    Formats GetFormats() const override {
        return Span<const Format>(SETOBJECTWITHPROTO_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        (*regs)[0] = &v_;
        return 1;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        (*regs)[0] = &v_;
        return 1;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::SETOBJECTWITHPROTO;
        ins->regs.reserve(1);
        ins->imms.reserve(1);
        ins->regs.emplace_back(v_);
        ins->imms.emplace_back(imm_);
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        constexpr static ICSlot invalid = 0xFF;
        if (slot <= 0xFF) {
            if ((slot + 2) > 0xFF) {
                imm_ = 0x100;
                return 2 + (0x100 - slot);
            }

            imm_ = slot;
            return 2;
        }

        if (slot > 0xFF && slot <= 0xFFFF) {
            imm_ = slot;
            return 2;
        }

        imm_ = invalid;
        return 0;
    }


private:
    int64_t imm_;
    VReg v_;
};

class Stownbyvalue : public IRNode
{
public:
    explicit Stownbyvalue(const ir::AstNode* node, int64_t imm, VReg v1, VReg v2) : IRNode(node), imm_(imm), v1_(v1), v2_(v2) {}

    Formats GetFormats() const override {
        return Span<const Format>(STOWNBYVALUE_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        (*regs)[0] = &v1_;
        (*regs)[1] = &v2_;
        return 2;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        (*regs)[0] = &v1_;
        (*regs)[1] = &v2_;
        return 2;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::STOWNBYVALUE;
        ins->regs.reserve(2);
        ins->imms.reserve(1);
        ins->regs.emplace_back(v1_);
        ins->regs.emplace_back(v2_);
        ins->imms.emplace_back(imm_);
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        constexpr static ICSlot invalid = 0xFF;
        if (slot <= 0xFF) {
            if ((slot + 2) > 0xFF) {
                imm_ = 0x100;
                return 2 + (0x100 - slot);
            }

            imm_ = slot;
            return 2;
        }

        if (slot > 0xFF && slot <= 0xFFFF) {
            imm_ = slot;
            return 2;
        }

        imm_ = invalid;
        return 0;
    }


private:
    int64_t imm_;
    VReg v1_;
    VReg v2_;
};

class Stownbyindex : public IRNode
{
public:
    explicit Stownbyindex(const ir::AstNode* node, int64_t imm1, VReg v, int64_t imm2) : IRNode(node), imm1_(imm1), v_(v), imm2_(imm2) {}

    Formats GetFormats() const override {
        return Span<const Format>(STOWNBYINDEX_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        (*regs)[0] = &v_;
        return 1;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        (*regs)[0] = &v_;
        return 1;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::STOWNBYINDEX;
        ins->regs.reserve(1);
        ins->imms.reserve(2);
        ins->regs.emplace_back(v_);
        ins->imms.emplace_back(imm1_);
        ins->imms.emplace_back(imm2_);
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        constexpr static ICSlot invalid = 0xFF;
        if (slot <= 0xFF) {
            if ((slot + 2) > 0xFF) {
                imm1_ = 0x100;
                return 2 + (0x100 - slot);
            }

            imm1_ = slot;
            return 2;
        }

        if (slot > 0xFF && slot <= 0xFFFF) {
            imm1_ = slot;
            return 2;
        }

        imm1_ = invalid;
        return 0;
    }


private:
    int64_t imm1_;
    VReg v_;
    int64_t imm2_;
};

class Stownbyname : public IRNode
{
public:
    explicit Stownbyname(const ir::AstNode* node, int64_t imm, util::StringView stringId_0, VReg v) : IRNode(node), imm_(imm), stringId_0_(stringId_0), v_(v) {}

    Formats GetFormats() const override {
        return Span<const Format>(STOWNBYNAME_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        (*regs)[0] = &v_;
        return 1;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        (*regs)[0] = &v_;
        return 1;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::STOWNBYNAME;
        ins->regs.reserve(1);
        ins->imms.reserve(1);
        ins->ids.reserve(1);
        ins->regs.emplace_back(v_);
        ins->imms.emplace_back(imm_);
        ins->ids.emplace_back(stringId_0_.Mutf8());
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        constexpr static ICSlot invalid = 0xFF;
        if (slot <= 0xFF) {
            if ((slot + 2) > 0xFF) {
                imm_ = 0x100;
                return 2 + (0x100 - slot);
            }

            imm_ = slot;
            return 2;
        }

        if (slot > 0xFF && slot <= 0xFFFF) {
            imm_ = slot;
            return 2;
        }

        imm_ = invalid;
        return 0;
    }


private:
    int64_t imm_;
    util::StringView stringId_0_;
    VReg v_;
};

class Getmodulenamespace : public IRNode
{
public:
    explicit Getmodulenamespace(const ir::AstNode* node, int64_t imm) : IRNode(node), imm_(imm) {}

    Formats GetFormats() const override {
        return Span<const Format>(GETMODULENAMESPACE_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        return 0;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        return 0;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::GETMODULENAMESPACE;
        ins->imms.reserve(1);
        ins->imms.emplace_back(imm_);
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        return 0;
    }


private:
    int64_t imm_;
};

class Stmodulevar : public IRNode
{
public:
    explicit Stmodulevar(const ir::AstNode* node, int64_t imm) : IRNode(node), imm_(imm) {}

    Formats GetFormats() const override {
        return Span<const Format>(STMODULEVAR_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        return 0;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        return 0;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::STMODULEVAR;
        ins->imms.reserve(1);
        ins->imms.emplace_back(imm_);
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        return 0;
    }


private:
    int64_t imm_;
};

class Ldlocalmodulevar : public IRNode
{
public:
    explicit Ldlocalmodulevar(const ir::AstNode* node, int64_t imm) : IRNode(node), imm_(imm) {}

    Formats GetFormats() const override {
        return Span<const Format>(LDLOCALMODULEVAR_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        return 0;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        return 0;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::LDLOCALMODULEVAR;
        ins->imms.reserve(1);
        ins->imms.emplace_back(imm_);
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        return 0;
    }


private:
    int64_t imm_;
};

class Ldexternalmodulevar : public IRNode
{
public:
    explicit Ldexternalmodulevar(const ir::AstNode* node, int64_t imm) : IRNode(node), imm_(imm) {}

    Formats GetFormats() const override {
        return Span<const Format>(LDEXTERNALMODULEVAR_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        return 0;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        return 0;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::LDEXTERNALMODULEVAR;
        ins->imms.reserve(1);
        ins->imms.emplace_back(imm_);
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        return 0;
    }


private:
    int64_t imm_;
};

class Stglobalvar : public IRNode
{
public:
    explicit Stglobalvar(const ir::AstNode* node, int64_t imm, util::StringView stringId_0) : IRNode(node), imm_(imm), stringId_0_(stringId_0) {}

    Formats GetFormats() const override {
        return Span<const Format>(STGLOBALVAR_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        return 0;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        return 0;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::STGLOBALVAR;
        ins->imms.reserve(1);
        ins->ids.reserve(1);
        ins->imms.emplace_back(imm_);
        ins->ids.emplace_back(stringId_0_.Mutf8());
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        constexpr static ICSlot invalid = 0xFF;
        if (slot <= 0xFF) {
            if ((slot + 1) > 0xFF) {
                imm_ = 0x100;
                return 1 + (0x100 - slot);
            }

            imm_ = slot;
            return 1;
        }

        if (slot > 0xFF && slot <= 0xFFFF) {
            imm_ = slot;
            return 1;
        }

        imm_ = invalid;
        return 0;
    }


private:
    int64_t imm_;
    util::StringView stringId_0_;
};

class Stownbynamewithnameset : public IRNode
{
public:
    explicit Stownbynamewithnameset(const ir::AstNode* node, int64_t imm, util::StringView stringId_0, VReg v) : IRNode(node), imm_(imm), stringId_0_(stringId_0), v_(v) {}

    Formats GetFormats() const override {
        return Span<const Format>(STOWNBYNAMEWITHNAMESET_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        (*regs)[0] = &v_;
        return 1;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        (*regs)[0] = &v_;
        return 1;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::STOWNBYNAMEWITHNAMESET;
        ins->regs.reserve(1);
        ins->imms.reserve(1);
        ins->ids.reserve(1);
        ins->regs.emplace_back(v_);
        ins->imms.emplace_back(imm_);
        ins->ids.emplace_back(stringId_0_.Mutf8());
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        constexpr static ICSlot invalid = 0xFF;
        if (slot <= 0xFF) {
            if ((slot + 2) > 0xFF) {
                imm_ = 0x100;
                return 2 + (0x100 - slot);
            }

            imm_ = slot;
            return 2;
        }

        if (slot > 0xFF && slot <= 0xFFFF) {
            imm_ = slot;
            return 2;
        }

        imm_ = invalid;
        return 0;
    }


private:
    int64_t imm_;
    util::StringView stringId_0_;
    VReg v_;
};

class Asyncgeneratorreject : public IRNode
{
public:
    explicit Asyncgeneratorreject(const ir::AstNode* node, VReg v) : IRNode(node), v_(v) {}

    Formats GetFormats() const override {
        return Span<const Format>(ASYNCGENERATORREJECT_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        (*regs)[0] = &v_;
        return 1;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        (*regs)[0] = &v_;
        return 1;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::ASYNCGENERATORREJECT;
        ins->regs.reserve(1);
        ins->regs.emplace_back(v_);
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        return 0;
    }


private:
    VReg v_;
};

class Stownbyvaluewithnameset : public IRNode
{
public:
    explicit Stownbyvaluewithnameset(const ir::AstNode* node, int64_t imm, VReg v1, VReg v2) : IRNode(node), imm_(imm), v1_(v1), v2_(v2) {}

    Formats GetFormats() const override {
        return Span<const Format>(STOWNBYVALUEWITHNAMESET_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        (*regs)[0] = &v1_;
        (*regs)[1] = &v2_;
        return 2;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        (*regs)[0] = &v1_;
        (*regs)[1] = &v2_;
        return 2;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::STOWNBYVALUEWITHNAMESET;
        ins->regs.reserve(2);
        ins->imms.reserve(1);
        ins->regs.emplace_back(v1_);
        ins->regs.emplace_back(v2_);
        ins->imms.emplace_back(imm_);
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        constexpr static ICSlot invalid = 0xFF;
        if (slot <= 0xFF) {
            if ((slot + 2) > 0xFF) {
                imm_ = 0x100;
                return 2 + (0x100 - slot);
            }

            imm_ = slot;
            return 2;
        }

        if (slot > 0xFF && slot <= 0xFFFF) {
            imm_ = slot;
            return 2;
        }

        imm_ = invalid;
        return 0;
    }


private:
    int64_t imm_;
    VReg v1_;
    VReg v2_;
};

class Ldsymbol : public IRNode
{
public:
    explicit Ldsymbol(const ir::AstNode* node) : IRNode(node) {}

    Formats GetFormats() const override {
        return Span<const Format>(LDSYMBOL_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        return 0;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        return 0;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::LDSYMBOL;
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        return 0;
    }


};

class Asyncfunctionenter : public IRNode
{
public:
    explicit Asyncfunctionenter(const ir::AstNode* node) : IRNode(node) {}

    Formats GetFormats() const override {
        return Span<const Format>(ASYNCFUNCTIONENTER_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        return 0;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        return 0;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::ASYNCFUNCTIONENTER;
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        return 0;
    }


};

class Ldfunction : public IRNode
{
public:
    explicit Ldfunction(const ir::AstNode* node) : IRNode(node) {}

    Formats GetFormats() const override {
        return Span<const Format>(LDFUNCTION_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        return 0;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        return 0;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::LDFUNCTION;
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        return 0;
    }


};

class Debugger : public IRNode
{
public:
    explicit Debugger(const ir::AstNode* node) : IRNode(node) {}

    Formats GetFormats() const override {
        return Span<const Format>(DEBUGGER_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        return 0;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        return 0;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::DEBUGGER;
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        return 0;
    }


};

class Creategeneratorobj : public IRNode
{
public:
    explicit Creategeneratorobj(const ir::AstNode* node, VReg v) : IRNode(node), v_(v) {}

    Formats GetFormats() const override {
        return Span<const Format>(CREATEGENERATOROBJ_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        (*regs)[0] = &v_;
        return 1;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        (*regs)[0] = &v_;
        return 1;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::CREATEGENERATOROBJ;
        ins->regs.reserve(1);
        ins->regs.emplace_back(v_);
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        return 0;
    }


private:
    VReg v_;
};

class Createiterresultobj : public IRNode
{
public:
    explicit Createiterresultobj(const ir::AstNode* node, VReg v1, VReg v2) : IRNode(node), v1_(v1), v2_(v2) {}

    Formats GetFormats() const override {
        return Span<const Format>(CREATEITERRESULTOBJ_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        (*regs)[0] = &v1_;
        (*regs)[1] = &v2_;
        return 2;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        (*regs)[0] = &v1_;
        (*regs)[1] = &v2_;
        return 2;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::CREATEITERRESULTOBJ;
        ins->regs.reserve(2);
        ins->regs.emplace_back(v1_);
        ins->regs.emplace_back(v2_);
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        return 0;
    }


private:
    VReg v1_;
    VReg v2_;
};

class Createobjectwithexcludedkeys : public IRNode
{
public:
    explicit Createobjectwithexcludedkeys(const ir::AstNode* node, int64_t imm, VReg v1, VReg v2) : IRNode(node), imm_(imm), v1_(v1), v2_(v2) {}

    Formats GetFormats() const override {
        return Span<const Format>(CREATEOBJECTWITHEXCLUDEDKEYS_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        (*regs)[0] = &v1_;
        (*regs)[1] = &v2_;
        return 2;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        (*regs)[0] = &v1_;
        (*regs)[1] = &v2_;
        return 2;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::CREATEOBJECTWITHEXCLUDEDKEYS;
        ins->regs.reserve(2);
        ins->imms.reserve(1);
        ins->regs.emplace_back(v1_);
        ins->regs.emplace_back(v2_);
        ins->imms.emplace_back(imm_);
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        return 0;
    }

    bool IsRangeInst() const override
    {
        return true;
    }

    int64_t RangeRegsCount() override
    {
        return imm_ + 1;
    }

private:
    int64_t imm_;
    VReg v1_;
    VReg v2_;
};

class Newobjapply : public IRNode
{
public:
    explicit Newobjapply(const ir::AstNode* node, int64_t imm, VReg v) : IRNode(node), imm_(imm), v_(v) {}

    Formats GetFormats() const override {
        return Span<const Format>(NEWOBJAPPLY_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        (*regs)[0] = &v_;
        return 1;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        (*regs)[0] = &v_;
        return 1;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::NEWOBJAPPLY;
        ins->regs.reserve(1);
        ins->imms.reserve(1);
        ins->regs.emplace_back(v_);
        ins->imms.emplace_back(imm_);
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        constexpr static ICSlot invalid = 0xFF;
        if (slot <= 0xFF) {
            if ((slot + 2) > 0xFF) {
                imm_ = 0x100;
                return 2 + (0x100 - slot);
            }

            imm_ = slot;
            return 2;
        }

        if (slot > 0xFF && slot <= 0xFFFF) {
            imm_ = slot;
            return 2;
        }

        imm_ = invalid;
        return 0;
    }


private:
    int64_t imm_;
    VReg v_;
};

class Newlexenvwithname : public IRNode
{
public:
    explicit Newlexenvwithname(const ir::AstNode* node, int64_t imm, util::StringView stringId_0) : IRNode(node), imm_(imm), stringId_0_(stringId_0) {}

    Formats GetFormats() const override {
        return Span<const Format>(NEWLEXENVWITHNAME_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        return 0;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        return 0;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::NEWLEXENVWITHNAME;
        ins->imms.reserve(1);
        ins->ids.reserve(1);
        ins->imms.emplace_back(imm_);
        ins->ids.emplace_back(stringId_0_.Mutf8());
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        return 0;
    }


private:
    int64_t imm_;
    util::StringView stringId_0_;
};

class Createasyncgeneratorobj : public IRNode
{
public:
    explicit Createasyncgeneratorobj(const ir::AstNode* node, VReg v) : IRNode(node), v_(v) {}

    Formats GetFormats() const override {
        return Span<const Format>(CREATEASYNCGENERATOROBJ_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        (*regs)[0] = &v_;
        return 1;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        (*regs)[0] = &v_;
        return 1;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::CREATEASYNCGENERATOROBJ;
        ins->regs.reserve(1);
        ins->regs.emplace_back(v_);
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        return 0;
    }


private:
    VReg v_;
};

class Asyncgeneratorresolve : public IRNode
{
public:
    explicit Asyncgeneratorresolve(const ir::AstNode* node, VReg v1, VReg v2, VReg v3) : IRNode(node), v1_(v1), v2_(v2), v3_(v3) {}

    Formats GetFormats() const override {
        return Span<const Format>(ASYNCGENERATORRESOLVE_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        (*regs)[0] = &v1_;
        (*regs)[1] = &v2_;
        (*regs)[2] = &v3_;
        return 3;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        (*regs)[0] = &v1_;
        (*regs)[1] = &v2_;
        (*regs)[2] = &v3_;
        return 3;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::ASYNCGENERATORRESOLVE;
        ins->regs.reserve(3);
        ins->regs.emplace_back(v1_);
        ins->regs.emplace_back(v2_);
        ins->regs.emplace_back(v3_);
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        return 0;
    }


private:
    VReg v1_;
    VReg v2_;
    VReg v3_;
};

class Supercallspread : public IRNode
{
public:
    explicit Supercallspread(const ir::AstNode* node, int64_t imm, VReg v) : IRNode(node), imm_(imm), v_(v) {}

    Formats GetFormats() const override {
        return Span<const Format>(SUPERCALLSPREAD_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        (*regs)[0] = &v_;
        return 1;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        (*regs)[0] = &v_;
        return 1;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::SUPERCALLSPREAD;
        ins->regs.reserve(1);
        ins->imms.reserve(1);
        ins->regs.emplace_back(v_);
        ins->imms.emplace_back(imm_);
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        constexpr static ICSlot invalid = 0xFF;
        if (slot < 0xFF) {
            if ((slot + 2) > 0xFF) {
                imm_ = invalid;
                return 0;
            }

            imm_ = slot;
            return 2;
        }

        imm_ = invalid;
        return 0;
    }


private:
    int64_t imm_;
    VReg v_;
};

class Apply : public IRNode
{
public:
    explicit Apply(const ir::AstNode* node, int64_t imm, VReg v1, VReg v2) : IRNode(node), imm_(imm), v1_(v1), v2_(v2) {}

    Formats GetFormats() const override {
        return Span<const Format>(APPLY_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        (*regs)[0] = &v1_;
        (*regs)[1] = &v2_;
        return 2;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        (*regs)[0] = &v1_;
        (*regs)[1] = &v2_;
        return 2;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::APPLY;
        ins->regs.reserve(2);
        ins->imms.reserve(1);
        ins->regs.emplace_back(v1_);
        ins->regs.emplace_back(v2_);
        ins->imms.emplace_back(imm_);
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        constexpr static ICSlot invalid = 0xFF;
        if (slot < 0xFF) {
            if ((slot + 2) > 0xFF) {
                imm_ = invalid;
                return 0;
            }

            imm_ = slot;
            return 2;
        }

        imm_ = invalid;
        return 0;
    }


private:
    int64_t imm_;
    VReg v1_;
    VReg v2_;
};

class Supercallarrowrange : public IRNode
{
public:
    explicit Supercallarrowrange(const ir::AstNode* node, int64_t imm1, int64_t imm2, VReg v) : IRNode(node), imm1_(imm1), imm2_(imm2), v_(v) {}

    Formats GetFormats() const override {
        return Span<const Format>(SUPERCALLARROWRANGE_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        (*regs)[0] = &v_;
        return 1;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        (*regs)[0] = &v_;
        return 1;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::SUPERCALLARROWRANGE;
        ins->regs.reserve(1);
        ins->imms.reserve(2);
        ins->regs.emplace_back(v_);
        ins->imms.emplace_back(imm1_);
        ins->imms.emplace_back(imm2_);
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        constexpr static ICSlot invalid = 0xFF;
        if (slot < 0xFF) {
            if ((slot + 2) > 0xFF) {
                imm1_ = invalid;
                return 0;
            }

            imm1_ = slot;
            return 2;
        }

        imm1_ = invalid;
        return 0;
    }

    bool IsRangeInst() const override
    {
        return true;
    }

    int64_t RangeRegsCount() override
    {
        return imm2_;
    }

private:
    int64_t imm1_;
    int64_t imm2_;
    VReg v_;
};

class Definegettersetterbyvalue : public IRNode
{
public:
    explicit Definegettersetterbyvalue(const ir::AstNode* node, VReg v1, VReg v2, VReg v3, VReg v4) : IRNode(node), v1_(v1), v2_(v2), v3_(v3), v4_(v4) {}

    Formats GetFormats() const override {
        return Span<const Format>(DEFINEGETTERSETTERBYVALUE_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        (*regs)[0] = &v1_;
        (*regs)[1] = &v2_;
        (*regs)[2] = &v3_;
        (*regs)[3] = &v4_;
        return 4;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        (*regs)[0] = &v1_;
        (*regs)[1] = &v2_;
        (*regs)[2] = &v3_;
        (*regs)[3] = &v4_;
        return 4;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::DEFINEGETTERSETTERBYVALUE;
        ins->regs.reserve(4);
        ins->regs.emplace_back(v1_);
        ins->regs.emplace_back(v2_);
        ins->regs.emplace_back(v3_);
        ins->regs.emplace_back(v4_);
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        return 0;
    }


private:
    VReg v1_;
    VReg v2_;
    VReg v3_;
    VReg v4_;
};

class Dynamicimport : public IRNode
{
public:
    explicit Dynamicimport(const ir::AstNode* node) : IRNode(node) {}

    Formats GetFormats() const override {
        return Span<const Format>(DYNAMICIMPORT_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        return 0;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        return 0;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::DYNAMICIMPORT;
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        return 0;
    }


};

class Resumegenerator : public IRNode
{
public:
    explicit Resumegenerator(const ir::AstNode* node) : IRNode(node) {}

    Formats GetFormats() const override {
        return Span<const Format>(RESUMEGENERATOR_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        return 0;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        return 0;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::RESUMEGENERATOR;
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        return 0;
    }


};

class Getresumemode : public IRNode
{
public:
    explicit Getresumemode(const ir::AstNode* node) : IRNode(node) {}

    Formats GetFormats() const override {
        return Span<const Format>(GETRESUMEMODE_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        return 0;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        return 0;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::GETRESUMEMODE;
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        return 0;
    }


};

class Delobjprop : public IRNode
{
public:
    explicit Delobjprop(const ir::AstNode* node, VReg v) : IRNode(node), v_(v) {}

    Formats GetFormats() const override {
        return Span<const Format>(DELOBJPROP_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        (*regs)[0] = &v_;
        return 1;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        (*regs)[0] = &v_;
        return 1;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::DELOBJPROP;
        ins->regs.reserve(1);
        ins->regs.emplace_back(v_);
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        return 0;
    }


private:
    VReg v_;
};

class Suspendgenerator : public IRNode
{
public:
    explicit Suspendgenerator(const ir::AstNode* node, VReg v) : IRNode(node), v_(v) {}

    Formats GetFormats() const override {
        return Span<const Format>(SUSPENDGENERATOR_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        (*regs)[0] = &v_;
        return 1;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        (*regs)[0] = &v_;
        return 1;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::SUSPENDGENERATOR;
        ins->regs.reserve(1);
        ins->regs.emplace_back(v_);
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        return 0;
    }


private:
    VReg v_;
};

class Asyncfunctionawaituncaught : public IRNode
{
public:
    explicit Asyncfunctionawaituncaught(const ir::AstNode* node, VReg v) : IRNode(node), v_(v) {}

    Formats GetFormats() const override {
        return Span<const Format>(ASYNCFUNCTIONAWAITUNCAUGHT_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        (*regs)[0] = &v_;
        return 1;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        (*regs)[0] = &v_;
        return 1;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::ASYNCFUNCTIONAWAITUNCAUGHT;
        ins->regs.reserve(1);
        ins->regs.emplace_back(v_);
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        return 0;
    }


private:
    VReg v_;
};

class Copydataproperties : public IRNode
{
public:
    explicit Copydataproperties(const ir::AstNode* node, VReg v) : IRNode(node), v_(v) {}

    Formats GetFormats() const override {
        return Span<const Format>(COPYDATAPROPERTIES_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        (*regs)[0] = &v_;
        return 1;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        (*regs)[0] = &v_;
        return 1;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::COPYDATAPROPERTIES;
        ins->regs.reserve(1);
        ins->regs.emplace_back(v_);
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        return 0;
    }


private:
    VReg v_;
};

class Starrayspread : public IRNode
{
public:
    explicit Starrayspread(const ir::AstNode* node, VReg v1, VReg v2) : IRNode(node), v1_(v1), v2_(v2) {}

    Formats GetFormats() const override {
        return Span<const Format>(STARRAYSPREAD_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        (*regs)[0] = &v1_;
        (*regs)[1] = &v2_;
        return 2;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        (*regs)[0] = &v1_;
        (*regs)[1] = &v2_;
        return 2;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::STARRAYSPREAD;
        ins->regs.reserve(2);
        ins->regs.emplace_back(v1_);
        ins->regs.emplace_back(v2_);
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        return 0;
    }


private:
    VReg v1_;
    VReg v2_;
};

class Stsuperbyvalue : public IRNode
{
public:
    explicit Stsuperbyvalue(const ir::AstNode* node, int64_t imm, VReg v1, VReg v2) : IRNode(node), imm_(imm), v1_(v1), v2_(v2) {}

    Formats GetFormats() const override {
        return Span<const Format>(STSUPERBYVALUE_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        (*regs)[0] = &v1_;
        (*regs)[1] = &v2_;
        return 2;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        (*regs)[0] = &v1_;
        (*regs)[1] = &v2_;
        return 2;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::STSUPERBYVALUE;
        ins->regs.reserve(2);
        ins->imms.reserve(1);
        ins->regs.emplace_back(v1_);
        ins->regs.emplace_back(v2_);
        ins->imms.emplace_back(imm_);
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        constexpr static ICSlot invalid = 0xFF;
        if (slot <= 0xFF) {
            if ((slot + 2) > 0xFF) {
                imm_ = 0x100;
                return 2 + (0x100 - slot);
            }

            imm_ = slot;
            return 2;
        }

        if (slot > 0xFF && slot <= 0xFFFF) {
            imm_ = slot;
            return 2;
        }

        imm_ = invalid;
        return 0;
    }


private:
    int64_t imm_;
    VReg v1_;
    VReg v2_;
};

class Asyncfunctionresolve : public IRNode
{
public:
    explicit Asyncfunctionresolve(const ir::AstNode* node, VReg v) : IRNode(node), v_(v) {}

    Formats GetFormats() const override {
        return Span<const Format>(ASYNCFUNCTIONRESOLVE_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        (*regs)[0] = &v_;
        return 1;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        (*regs)[0] = &v_;
        return 1;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::ASYNCFUNCTIONRESOLVE;
        ins->regs.reserve(1);
        ins->regs.emplace_back(v_);
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        return 0;
    }


private:
    VReg v_;
};

class Asyncfunctionreject : public IRNode
{
public:
    explicit Asyncfunctionreject(const ir::AstNode* node, VReg v) : IRNode(node), v_(v) {}

    Formats GetFormats() const override {
        return Span<const Format>(ASYNCFUNCTIONREJECT_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        (*regs)[0] = &v_;
        return 1;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        (*regs)[0] = &v_;
        return 1;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::ASYNCFUNCTIONREJECT;
        ins->regs.reserve(1);
        ins->regs.emplace_back(v_);
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        return 0;
    }


private:
    VReg v_;
};

class Copyrestargs : public IRNode
{
public:
    explicit Copyrestargs(const ir::AstNode* node, int64_t imm) : IRNode(node), imm_(imm) {}

    Formats GetFormats() const override {
        return Span<const Format>(COPYRESTARGS_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        return 0;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        return 0;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::COPYRESTARGS;
        ins->imms.reserve(1);
        ins->imms.emplace_back(imm_);
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        return 0;
    }


private:
    int64_t imm_;
};

class Stsuperbyname : public IRNode
{
public:
    explicit Stsuperbyname(const ir::AstNode* node, int64_t imm, util::StringView stringId_0, VReg v) : IRNode(node), imm_(imm), stringId_0_(stringId_0), v_(v) {}

    Formats GetFormats() const override {
        return Span<const Format>(STSUPERBYNAME_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        (*regs)[0] = &v_;
        return 1;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        (*regs)[0] = &v_;
        return 1;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::STSUPERBYNAME;
        ins->regs.reserve(1);
        ins->imms.reserve(1);
        ins->ids.reserve(1);
        ins->regs.emplace_back(v_);
        ins->imms.emplace_back(imm_);
        ins->ids.emplace_back(stringId_0_.Mutf8());
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        constexpr static ICSlot invalid = 0xFF;
        if (slot <= 0xFF) {
            if ((slot + 2) > 0xFF) {
                imm_ = 0x100;
                return 2 + (0x100 - slot);
            }

            imm_ = slot;
            return 2;
        }

        if (slot > 0xFF && slot <= 0xFFFF) {
            imm_ = slot;
            return 2;
        }

        imm_ = invalid;
        return 0;
    }


private:
    int64_t imm_;
    util::StringView stringId_0_;
    VReg v_;
};

class Ldbigint : public IRNode
{
public:
    explicit Ldbigint(const ir::AstNode* node, util::StringView stringId_0) : IRNode(node), stringId_0_(stringId_0) {}

    Formats GetFormats() const override {
        return Span<const Format>(LDBIGINT_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        return 0;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        return 0;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::LDBIGINT;
        ins->ids.reserve(1);
        ins->ids.emplace_back(stringId_0_.Mutf8());
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        return 0;
    }


private:
    util::StringView stringId_0_;
};

class Nop : public IRNode
{
public:
    explicit Nop(const ir::AstNode* node) : IRNode(node) {}

    Formats GetFormats() const override {
        return Span<const Format>(NOP_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        return 0;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        return 0;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::NOP;
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        return 0;
    }


};

class Setgeneratorstate : public IRNode
{
public:
    explicit Setgeneratorstate(const ir::AstNode* node, int64_t imm) : IRNode(node), imm_(imm) {}

    Formats GetFormats() const override {
        return Span<const Format>(SETGENERATORSTATE_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        return 0;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        return 0;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::SETGENERATORSTATE;
        ins->imms.reserve(1);
        ins->imms.emplace_back(imm_);
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        return 0;
    }


private:
    int64_t imm_;
};

class Getasynciterator : public IRNode
{
public:
    explicit Getasynciterator(const ir::AstNode* node, int64_t imm) : IRNode(node), imm_(imm) {}

    Formats GetFormats() const override {
        return Span<const Format>(GETASYNCITERATOR_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        return 0;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        return 0;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::GETASYNCITERATOR;
        ins->imms.reserve(1);
        ins->imms.emplace_back(imm_);
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        constexpr static ICSlot invalid = 0xFF;
        if (slot <= 0xFF) {
            if ((slot + 2) > 0xFF) {
                imm_ = 0x100;
                return 2 + (0x100 - slot);
            }

            imm_ = slot;
            return 2;
        }

        if (slot > 0xFF && slot <= 0xFFFF) {
            imm_ = slot;
            return 2;
        }

        imm_ = invalid;
        return 0;
    }


private:
    int64_t imm_;
};

class CallruntimeNotifyconcurrentresult : public IRNode
{
public:
    explicit CallruntimeNotifyconcurrentresult(const ir::AstNode* node) : IRNode(node) {}

    Formats GetFormats() const override {
        return Span<const Format>(CALLRUNTIME_NOTIFYCONCURRENTRESULT_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        return 0;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        return 0;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::CALLRUNTIME_NOTIFYCONCURRENTRESULT;
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        return 0;
    }


};

class DeprecatedLdlexenv : public IRNode
{
public:
    explicit DeprecatedLdlexenv(const ir::AstNode* node) : IRNode(node) {}

    Formats GetFormats() const override {
        return Span<const Format>(DEPRECATED_LDLEXENV_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        return 0;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        return 0;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::DEPRECATED_LDLEXENV;
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        return 0;
    }


};

class WideCreateobjectwithexcludedkeys : public IRNode
{
public:
    explicit WideCreateobjectwithexcludedkeys(const ir::AstNode* node, int64_t imm, VReg v1, VReg v2) : IRNode(node), imm_(imm), v1_(v1), v2_(v2) {}

    Formats GetFormats() const override {
        return Span<const Format>(WIDE_CREATEOBJECTWITHEXCLUDEDKEYS_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        (*regs)[0] = &v1_;
        (*regs)[1] = &v2_;
        return 2;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        (*regs)[0] = &v1_;
        (*regs)[1] = &v2_;
        return 2;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::WIDE_CREATEOBJECTWITHEXCLUDEDKEYS;
        ins->regs.reserve(2);
        ins->imms.reserve(1);
        ins->regs.emplace_back(v1_);
        ins->regs.emplace_back(v2_);
        ins->imms.emplace_back(imm_);
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        return 0;
    }

    bool IsRangeInst() const override
    {
        return true;
    }

    int64_t RangeRegsCount() override
    {
        return imm_ + 1;
    }

private:
    int64_t imm_;
    VReg v1_;
    VReg v2_;
};

class Throw : public IRNode
{
public:
    explicit Throw(const ir::AstNode* node) : IRNode(node) {}

    Formats GetFormats() const override {
        return Span<const Format>(THROW_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        return 0;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        return 0;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::THROW;
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        return 0;
    }


};

class DeprecatedPoplexenv : public IRNode
{
public:
    explicit DeprecatedPoplexenv(const ir::AstNode* node) : IRNode(node) {}

    Formats GetFormats() const override {
        return Span<const Format>(DEPRECATED_POPLEXENV_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        return 0;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        return 0;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::DEPRECATED_POPLEXENV;
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        return 0;
    }


};

class WideNewobjrange : public IRNode
{
public:
    explicit WideNewobjrange(const ir::AstNode* node, int64_t imm, VReg v) : IRNode(node), imm_(imm), v_(v) {}

    Formats GetFormats() const override {
        return Span<const Format>(WIDE_NEWOBJRANGE_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        (*regs)[0] = &v_;
        return 1;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        (*regs)[0] = &v_;
        return 1;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::WIDE_NEWOBJRANGE;
        ins->regs.reserve(1);
        ins->imms.reserve(1);
        ins->regs.emplace_back(v_);
        ins->imms.emplace_back(imm_);
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        return 0;
    }

    bool IsRangeInst() const override
    {
        return true;
    }

    int64_t RangeRegsCount() override
    {
        return imm_;
    }

private:
    int64_t imm_;
    VReg v_;
};

class ThrowNotexists : public IRNode
{
public:
    explicit ThrowNotexists(const ir::AstNode* node) : IRNode(node) {}

    Formats GetFormats() const override {
        return Span<const Format>(THROW_NOTEXISTS_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        return 0;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        return 0;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::THROW_NOTEXISTS;
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        return 0;
    }


};

class DeprecatedGetiteratornext : public IRNode
{
public:
    explicit DeprecatedGetiteratornext(const ir::AstNode* node, VReg v1, VReg v2) : IRNode(node), v1_(v1), v2_(v2) {}

    Formats GetFormats() const override {
        return Span<const Format>(DEPRECATED_GETITERATORNEXT_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        (*regs)[0] = &v1_;
        (*regs)[1] = &v2_;
        return 2;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        (*regs)[0] = &v1_;
        (*regs)[1] = &v2_;
        return 2;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::DEPRECATED_GETITERATORNEXT;
        ins->regs.reserve(2);
        ins->regs.emplace_back(v1_);
        ins->regs.emplace_back(v2_);
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        return 0;
    }


private:
    VReg v1_;
    VReg v2_;
};

class WideNewlexenv : public IRNode
{
public:
    explicit WideNewlexenv(const ir::AstNode* node, int64_t imm) : IRNode(node), imm_(imm) {}

    Formats GetFormats() const override {
        return Span<const Format>(WIDE_NEWLEXENV_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        return 0;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        return 0;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::WIDE_NEWLEXENV;
        ins->imms.reserve(1);
        ins->imms.emplace_back(imm_);
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        return 0;
    }


private:
    int64_t imm_;
};

class ThrowPatternnoncoercible : public IRNode
{
public:
    explicit ThrowPatternnoncoercible(const ir::AstNode* node) : IRNode(node) {}

    Formats GetFormats() const override {
        return Span<const Format>(THROW_PATTERNNONCOERCIBLE_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        return 0;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        return 0;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::THROW_PATTERNNONCOERCIBLE;
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        return 0;
    }


};

class DeprecatedCreatearraywithbuffer : public IRNode
{
public:
    explicit DeprecatedCreatearraywithbuffer(const ir::AstNode* node, int64_t imm) : IRNode(node), imm_(imm) {}

    Formats GetFormats() const override {
        return Span<const Format>(DEPRECATED_CREATEARRAYWITHBUFFER_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        return 0;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        return 0;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::DEPRECATED_CREATEARRAYWITHBUFFER;
        ins->imms.reserve(1);
        ins->imms.emplace_back(imm_);
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        return 0;
    }


private:
    int64_t imm_;
};

class WideNewlexenvwithname : public IRNode
{
public:
    explicit WideNewlexenvwithname(const ir::AstNode* node, int64_t imm, util::StringView stringId_0) : IRNode(node), imm_(imm), stringId_0_(stringId_0) {}

    Formats GetFormats() const override {
        return Span<const Format>(WIDE_NEWLEXENVWITHNAME_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        return 0;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        return 0;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::WIDE_NEWLEXENVWITHNAME;
        ins->imms.reserve(1);
        ins->ids.reserve(1);
        ins->imms.emplace_back(imm_);
        ins->ids.emplace_back(stringId_0_.Mutf8());
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        return 0;
    }


private:
    int64_t imm_;
    util::StringView stringId_0_;
};

class ThrowDeletesuperproperty : public IRNode
{
public:
    explicit ThrowDeletesuperproperty(const ir::AstNode* node) : IRNode(node) {}

    Formats GetFormats() const override {
        return Span<const Format>(THROW_DELETESUPERPROPERTY_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        return 0;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        return 0;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::THROW_DELETESUPERPROPERTY;
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        return 0;
    }


};

class DeprecatedCreateobjectwithbuffer : public IRNode
{
public:
    explicit DeprecatedCreateobjectwithbuffer(const ir::AstNode* node, int64_t imm) : IRNode(node), imm_(imm) {}

    Formats GetFormats() const override {
        return Span<const Format>(DEPRECATED_CREATEOBJECTWITHBUFFER_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        return 0;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        return 0;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::DEPRECATED_CREATEOBJECTWITHBUFFER;
        ins->imms.reserve(1);
        ins->imms.emplace_back(imm_);
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        return 0;
    }


private:
    int64_t imm_;
};

class WideCallrange : public IRNode
{
public:
    explicit WideCallrange(const ir::AstNode* node, int64_t imm, VReg v) : IRNode(node), imm_(imm), v_(v) {}

    Formats GetFormats() const override {
        return Span<const Format>(WIDE_CALLRANGE_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        (*regs)[0] = &v_;
        return 1;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        (*regs)[0] = &v_;
        return 1;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::WIDE_CALLRANGE;
        ins->regs.reserve(1);
        ins->imms.reserve(1);
        ins->regs.emplace_back(v_);
        ins->imms.emplace_back(imm_);
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        return 0;
    }

    bool IsRangeInst() const override
    {
        return true;
    }

    int64_t RangeRegsCount() override
    {
        return imm_;
    }

private:
    int64_t imm_;
    VReg v_;
};

class ThrowConstassignment : public IRNode
{
public:
    explicit ThrowConstassignment(const ir::AstNode* node, VReg v) : IRNode(node), v_(v) {}

    Formats GetFormats() const override {
        return Span<const Format>(THROW_CONSTASSIGNMENT_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        (*regs)[0] = &v_;
        return 1;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        (*regs)[0] = &v_;
        return 1;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::THROW_CONSTASSIGNMENT;
        ins->regs.reserve(1);
        ins->regs.emplace_back(v_);
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        return 0;
    }


private:
    VReg v_;
};

class DeprecatedTonumber : public IRNode
{
public:
    explicit DeprecatedTonumber(const ir::AstNode* node, VReg v) : IRNode(node), v_(v) {}

    Formats GetFormats() const override {
        return Span<const Format>(DEPRECATED_TONUMBER_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        (*regs)[0] = &v_;
        return 1;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        (*regs)[0] = &v_;
        return 1;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::DEPRECATED_TONUMBER;
        ins->regs.reserve(1);
        ins->regs.emplace_back(v_);
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        return 0;
    }


private:
    VReg v_;
};

class WideCallthisrange : public IRNode
{
public:
    explicit WideCallthisrange(const ir::AstNode* node, int64_t imm, VReg v) : IRNode(node), imm_(imm), v_(v) {}

    Formats GetFormats() const override {
        return Span<const Format>(WIDE_CALLTHISRANGE_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        (*regs)[0] = &v_;
        return 1;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        (*regs)[0] = &v_;
        return 1;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::WIDE_CALLTHISRANGE;
        ins->regs.reserve(1);
        ins->imms.reserve(1);
        ins->regs.emplace_back(v_);
        ins->imms.emplace_back(imm_);
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        return 0;
    }

    bool IsRangeInst() const override
    {
        return true;
    }

    int64_t RangeRegsCount() override
    {
        return imm_ + 1;
    }

private:
    int64_t imm_;
    VReg v_;
};

class ThrowIfnotobject : public IRNode
{
public:
    explicit ThrowIfnotobject(const ir::AstNode* node, VReg v) : IRNode(node), v_(v) {}

    Formats GetFormats() const override {
        return Span<const Format>(THROW_IFNOTOBJECT_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        (*regs)[0] = &v_;
        return 1;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        (*regs)[0] = &v_;
        return 1;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::THROW_IFNOTOBJECT;
        ins->regs.reserve(1);
        ins->regs.emplace_back(v_);
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        return 0;
    }


private:
    VReg v_;
};

class DeprecatedTonumeric : public IRNode
{
public:
    explicit DeprecatedTonumeric(const ir::AstNode* node, VReg v) : IRNode(node), v_(v) {}

    Formats GetFormats() const override {
        return Span<const Format>(DEPRECATED_TONUMERIC_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        (*regs)[0] = &v_;
        return 1;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        (*regs)[0] = &v_;
        return 1;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::DEPRECATED_TONUMERIC;
        ins->regs.reserve(1);
        ins->regs.emplace_back(v_);
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        return 0;
    }


private:
    VReg v_;
};

class WideSupercallthisrange : public IRNode
{
public:
    explicit WideSupercallthisrange(const ir::AstNode* node, int64_t imm, VReg v) : IRNode(node), imm_(imm), v_(v) {}

    Formats GetFormats() const override {
        return Span<const Format>(WIDE_SUPERCALLTHISRANGE_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        (*regs)[0] = &v_;
        return 1;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        (*regs)[0] = &v_;
        return 1;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::WIDE_SUPERCALLTHISRANGE;
        ins->regs.reserve(1);
        ins->imms.reserve(1);
        ins->regs.emplace_back(v_);
        ins->imms.emplace_back(imm_);
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        return 0;
    }

    bool IsRangeInst() const override
    {
        return true;
    }

    int64_t RangeRegsCount() override
    {
        return imm_;
    }

private:
    int64_t imm_;
    VReg v_;
};

class ThrowUndefinedifhole : public IRNode
{
public:
    explicit ThrowUndefinedifhole(const ir::AstNode* node, VReg v1, VReg v2) : IRNode(node), v1_(v1), v2_(v2) {}

    Formats GetFormats() const override {
        return Span<const Format>(THROW_UNDEFINEDIFHOLE_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        (*regs)[0] = &v1_;
        (*regs)[1] = &v2_;
        return 2;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        (*regs)[0] = &v1_;
        (*regs)[1] = &v2_;
        return 2;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::THROW_UNDEFINEDIFHOLE;
        ins->regs.reserve(2);
        ins->regs.emplace_back(v1_);
        ins->regs.emplace_back(v2_);
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        return 0;
    }


private:
    VReg v1_;
    VReg v2_;
};

class DeprecatedNeg : public IRNode
{
public:
    explicit DeprecatedNeg(const ir::AstNode* node, VReg v) : IRNode(node), v_(v) {}

    Formats GetFormats() const override {
        return Span<const Format>(DEPRECATED_NEG_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        (*regs)[0] = &v_;
        return 1;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        (*regs)[0] = &v_;
        return 1;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::DEPRECATED_NEG;
        ins->regs.reserve(1);
        ins->regs.emplace_back(v_);
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        return 0;
    }


private:
    VReg v_;
};

class WideSupercallarrowrange : public IRNode
{
public:
    explicit WideSupercallarrowrange(const ir::AstNode* node, int64_t imm, VReg v) : IRNode(node), imm_(imm), v_(v) {}

    Formats GetFormats() const override {
        return Span<const Format>(WIDE_SUPERCALLARROWRANGE_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        (*regs)[0] = &v_;
        return 1;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        (*regs)[0] = &v_;
        return 1;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::WIDE_SUPERCALLARROWRANGE;
        ins->regs.reserve(1);
        ins->imms.reserve(1);
        ins->regs.emplace_back(v_);
        ins->imms.emplace_back(imm_);
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        return 0;
    }

    bool IsRangeInst() const override
    {
        return true;
    }

    int64_t RangeRegsCount() override
    {
        return imm_;
    }

private:
    int64_t imm_;
    VReg v_;
};

class ThrowIfsupernotcorrectcall : public IRNode
{
public:
    explicit ThrowIfsupernotcorrectcall(const ir::AstNode* node, int64_t imm) : IRNode(node), imm_(imm) {}

    Formats GetFormats() const override {
        return Span<const Format>(THROW_IFSUPERNOTCORRECTCALL_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        return 0;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        return 0;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::THROW_IFSUPERNOTCORRECTCALL;
        ins->imms.reserve(1);
        ins->imms.emplace_back(imm_);
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        return 0;
    }


private:
    int64_t imm_;
};

class DeprecatedNot : public IRNode
{
public:
    explicit DeprecatedNot(const ir::AstNode* node, VReg v) : IRNode(node), v_(v) {}

    Formats GetFormats() const override {
        return Span<const Format>(DEPRECATED_NOT_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        (*regs)[0] = &v_;
        return 1;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        (*regs)[0] = &v_;
        return 1;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::DEPRECATED_NOT;
        ins->regs.reserve(1);
        ins->regs.emplace_back(v_);
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        return 0;
    }


private:
    VReg v_;
};

class WideLdobjbyindex : public IRNode
{
public:
    explicit WideLdobjbyindex(const ir::AstNode* node, int64_t imm) : IRNode(node), imm_(imm) {}

    Formats GetFormats() const override {
        return Span<const Format>(WIDE_LDOBJBYINDEX_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        return 0;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        return 0;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::WIDE_LDOBJBYINDEX;
        ins->imms.reserve(1);
        ins->imms.emplace_back(imm_);
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        return 0;
    }


private:
    int64_t imm_;
};

class DeprecatedInc : public IRNode
{
public:
    explicit DeprecatedInc(const ir::AstNode* node, VReg v) : IRNode(node), v_(v) {}

    Formats GetFormats() const override {
        return Span<const Format>(DEPRECATED_INC_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        (*regs)[0] = &v_;
        return 1;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        (*regs)[0] = &v_;
        return 1;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::DEPRECATED_INC;
        ins->regs.reserve(1);
        ins->regs.emplace_back(v_);
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        return 0;
    }


private:
    VReg v_;
};

class WideStobjbyindex : public IRNode
{
public:
    explicit WideStobjbyindex(const ir::AstNode* node, VReg v, int64_t imm) : IRNode(node), v_(v), imm_(imm) {}

    Formats GetFormats() const override {
        return Span<const Format>(WIDE_STOBJBYINDEX_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        (*regs)[0] = &v_;
        return 1;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        (*regs)[0] = &v_;
        return 1;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::WIDE_STOBJBYINDEX;
        ins->regs.reserve(1);
        ins->imms.reserve(1);
        ins->regs.emplace_back(v_);
        ins->imms.emplace_back(imm_);
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        return 0;
    }


private:
    VReg v_;
    int64_t imm_;
};

class ThrowUndefinedifholewithname : public IRNode
{
public:
    explicit ThrowUndefinedifholewithname(const ir::AstNode* node, util::StringView stringId_0) : IRNode(node), stringId_0_(stringId_0) {}

    Formats GetFormats() const override {
        return Span<const Format>(THROW_UNDEFINEDIFHOLEWITHNAME_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        return 0;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        return 0;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::THROW_UNDEFINEDIFHOLEWITHNAME;
        ins->ids.reserve(1);
        ins->ids.emplace_back(stringId_0_.Mutf8());
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        return 0;
    }


private:
    util::StringView stringId_0_;
};

class DeprecatedDec : public IRNode
{
public:
    explicit DeprecatedDec(const ir::AstNode* node, VReg v) : IRNode(node), v_(v) {}

    Formats GetFormats() const override {
        return Span<const Format>(DEPRECATED_DEC_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        (*regs)[0] = &v_;
        return 1;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        (*regs)[0] = &v_;
        return 1;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::DEPRECATED_DEC;
        ins->regs.reserve(1);
        ins->regs.emplace_back(v_);
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        return 0;
    }


private:
    VReg v_;
};

class WideStownbyindex : public IRNode
{
public:
    explicit WideStownbyindex(const ir::AstNode* node, VReg v, int64_t imm) : IRNode(node), v_(v), imm_(imm) {}

    Formats GetFormats() const override {
        return Span<const Format>(WIDE_STOWNBYINDEX_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        (*regs)[0] = &v_;
        return 1;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        (*regs)[0] = &v_;
        return 1;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::WIDE_STOWNBYINDEX;
        ins->regs.reserve(1);
        ins->imms.reserve(1);
        ins->regs.emplace_back(v_);
        ins->imms.emplace_back(imm_);
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        return 0;
    }


private:
    VReg v_;
    int64_t imm_;
};

class DeprecatedCallarg0 : public IRNode
{
public:
    explicit DeprecatedCallarg0(const ir::AstNode* node, VReg v) : IRNode(node), v_(v) {}

    Formats GetFormats() const override {
        return Span<const Format>(DEPRECATED_CALLARG0_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        (*regs)[0] = &v_;
        return 1;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        (*regs)[0] = &v_;
        return 1;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::DEPRECATED_CALLARG0;
        ins->regs.reserve(1);
        ins->regs.emplace_back(v_);
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        return 0;
    }


private:
    VReg v_;
};

class WideCopyrestargs : public IRNode
{
public:
    explicit WideCopyrestargs(const ir::AstNode* node, int64_t imm) : IRNode(node), imm_(imm) {}

    Formats GetFormats() const override {
        return Span<const Format>(WIDE_COPYRESTARGS_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        return 0;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        return 0;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::WIDE_COPYRESTARGS;
        ins->imms.reserve(1);
        ins->imms.emplace_back(imm_);
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        return 0;
    }


private:
    int64_t imm_;
};

class DeprecatedCallarg1 : public IRNode
{
public:
    explicit DeprecatedCallarg1(const ir::AstNode* node, VReg v1, VReg v2) : IRNode(node), v1_(v1), v2_(v2) {}

    Formats GetFormats() const override {
        return Span<const Format>(DEPRECATED_CALLARG1_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        (*regs)[0] = &v1_;
        (*regs)[1] = &v2_;
        return 2;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        (*regs)[0] = &v1_;
        (*regs)[1] = &v2_;
        return 2;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::DEPRECATED_CALLARG1;
        ins->regs.reserve(2);
        ins->regs.emplace_back(v1_);
        ins->regs.emplace_back(v2_);
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        return 0;
    }


private:
    VReg v1_;
    VReg v2_;
};

class WideLdlexvar : public IRNode
{
public:
    explicit WideLdlexvar(const ir::AstNode* node, int64_t imm1, int64_t imm2) : IRNode(node), imm1_(imm1), imm2_(imm2) {}

    Formats GetFormats() const override {
        return Span<const Format>(WIDE_LDLEXVAR_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        return 0;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        return 0;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::WIDE_LDLEXVAR;
        ins->imms.reserve(2);
        ins->imms.emplace_back(imm1_);
        ins->imms.emplace_back(imm2_);
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        return 0;
    }


private:
    int64_t imm1_;
    int64_t imm2_;
};

class DeprecatedCallargs2 : public IRNode
{
public:
    explicit DeprecatedCallargs2(const ir::AstNode* node, VReg v1, VReg v2, VReg v3) : IRNode(node), v1_(v1), v2_(v2), v3_(v3) {}

    Formats GetFormats() const override {
        return Span<const Format>(DEPRECATED_CALLARGS2_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        (*regs)[0] = &v1_;
        (*regs)[1] = &v2_;
        (*regs)[2] = &v3_;
        return 3;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        (*regs)[0] = &v1_;
        (*regs)[1] = &v2_;
        (*regs)[2] = &v3_;
        return 3;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::DEPRECATED_CALLARGS2;
        ins->regs.reserve(3);
        ins->regs.emplace_back(v1_);
        ins->regs.emplace_back(v2_);
        ins->regs.emplace_back(v3_);
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        return 0;
    }


private:
    VReg v1_;
    VReg v2_;
    VReg v3_;
};

class WideStlexvar : public IRNode
{
public:
    explicit WideStlexvar(const ir::AstNode* node, int64_t imm1, int64_t imm2) : IRNode(node), imm1_(imm1), imm2_(imm2) {}

    Formats GetFormats() const override {
        return Span<const Format>(WIDE_STLEXVAR_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        return 0;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        return 0;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::WIDE_STLEXVAR;
        ins->imms.reserve(2);
        ins->imms.emplace_back(imm1_);
        ins->imms.emplace_back(imm2_);
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        return 0;
    }


private:
    int64_t imm1_;
    int64_t imm2_;
};

class DeprecatedCallargs3 : public IRNode
{
public:
    explicit DeprecatedCallargs3(const ir::AstNode* node, VReg v1, VReg v2, VReg v3, VReg v4) : IRNode(node), v1_(v1), v2_(v2), v3_(v3), v4_(v4) {}

    Formats GetFormats() const override {
        return Span<const Format>(DEPRECATED_CALLARGS3_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        (*regs)[0] = &v1_;
        (*regs)[1] = &v2_;
        (*regs)[2] = &v3_;
        (*regs)[3] = &v4_;
        return 4;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        (*regs)[0] = &v1_;
        (*regs)[1] = &v2_;
        (*regs)[2] = &v3_;
        (*regs)[3] = &v4_;
        return 4;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::DEPRECATED_CALLARGS3;
        ins->regs.reserve(4);
        ins->regs.emplace_back(v1_);
        ins->regs.emplace_back(v2_);
        ins->regs.emplace_back(v3_);
        ins->regs.emplace_back(v4_);
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        return 0;
    }


private:
    VReg v1_;
    VReg v2_;
    VReg v3_;
    VReg v4_;
};

class WideGetmodulenamespace : public IRNode
{
public:
    explicit WideGetmodulenamespace(const ir::AstNode* node, int64_t imm) : IRNode(node), imm_(imm) {}

    Formats GetFormats() const override {
        return Span<const Format>(WIDE_GETMODULENAMESPACE_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        return 0;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        return 0;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::WIDE_GETMODULENAMESPACE;
        ins->imms.reserve(1);
        ins->imms.emplace_back(imm_);
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        return 0;
    }


private:
    int64_t imm_;
};

class DeprecatedCallrange : public IRNode
{
public:
    explicit DeprecatedCallrange(const ir::AstNode* node, int64_t imm, VReg v) : IRNode(node), imm_(imm), v_(v) {}

    Formats GetFormats() const override {
        return Span<const Format>(DEPRECATED_CALLRANGE_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        (*regs)[0] = &v_;
        return 1;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        (*regs)[0] = &v_;
        return 1;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::DEPRECATED_CALLRANGE;
        ins->regs.reserve(1);
        ins->imms.reserve(1);
        ins->regs.emplace_back(v_);
        ins->imms.emplace_back(imm_);
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        return 0;
    }


private:
    int64_t imm_;
    VReg v_;
};

class WideStmodulevar : public IRNode
{
public:
    explicit WideStmodulevar(const ir::AstNode* node, int64_t imm) : IRNode(node), imm_(imm) {}

    Formats GetFormats() const override {
        return Span<const Format>(WIDE_STMODULEVAR_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        return 0;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        return 0;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::WIDE_STMODULEVAR;
        ins->imms.reserve(1);
        ins->imms.emplace_back(imm_);
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        return 0;
    }


private:
    int64_t imm_;
};

class DeprecatedCallspread : public IRNode
{
public:
    explicit DeprecatedCallspread(const ir::AstNode* node, VReg v1, VReg v2, VReg v3) : IRNode(node), v1_(v1), v2_(v2), v3_(v3) {}

    Formats GetFormats() const override {
        return Span<const Format>(DEPRECATED_CALLSPREAD_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        (*regs)[0] = &v1_;
        (*regs)[1] = &v2_;
        (*regs)[2] = &v3_;
        return 3;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        (*regs)[0] = &v1_;
        (*regs)[1] = &v2_;
        (*regs)[2] = &v3_;
        return 3;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::DEPRECATED_CALLSPREAD;
        ins->regs.reserve(3);
        ins->regs.emplace_back(v1_);
        ins->regs.emplace_back(v2_);
        ins->regs.emplace_back(v3_);
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        return 0;
    }


private:
    VReg v1_;
    VReg v2_;
    VReg v3_;
};

class WideLdlocalmodulevar : public IRNode
{
public:
    explicit WideLdlocalmodulevar(const ir::AstNode* node, int64_t imm) : IRNode(node), imm_(imm) {}

    Formats GetFormats() const override {
        return Span<const Format>(WIDE_LDLOCALMODULEVAR_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        return 0;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        return 0;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::WIDE_LDLOCALMODULEVAR;
        ins->imms.reserve(1);
        ins->imms.emplace_back(imm_);
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        return 0;
    }


private:
    int64_t imm_;
};

class DeprecatedCallthisrange : public IRNode
{
public:
    explicit DeprecatedCallthisrange(const ir::AstNode* node, int64_t imm, VReg v) : IRNode(node), imm_(imm), v_(v) {}

    Formats GetFormats() const override {
        return Span<const Format>(DEPRECATED_CALLTHISRANGE_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        (*regs)[0] = &v_;
        return 1;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        (*regs)[0] = &v_;
        return 1;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::DEPRECATED_CALLTHISRANGE;
        ins->regs.reserve(1);
        ins->imms.reserve(1);
        ins->regs.emplace_back(v_);
        ins->imms.emplace_back(imm_);
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        return 0;
    }


private:
    int64_t imm_;
    VReg v_;
};

class WideLdexternalmodulevar : public IRNode
{
public:
    explicit WideLdexternalmodulevar(const ir::AstNode* node, int64_t imm) : IRNode(node), imm_(imm) {}

    Formats GetFormats() const override {
        return Span<const Format>(WIDE_LDEXTERNALMODULEVAR_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        return 0;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        return 0;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::WIDE_LDEXTERNALMODULEVAR;
        ins->imms.reserve(1);
        ins->imms.emplace_back(imm_);
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        return 0;
    }


private:
    int64_t imm_;
};

class DeprecatedDefineclasswithbuffer : public IRNode
{
public:
    explicit DeprecatedDefineclasswithbuffer(const ir::AstNode* node, util::StringView stringId_0, int64_t imm1, int64_t imm2, VReg v1, VReg v2) : IRNode(node), stringId_0_(stringId_0), imm1_(imm1), imm2_(imm2), v1_(v1), v2_(v2) {}

    Formats GetFormats() const override {
        return Span<const Format>(DEPRECATED_DEFINECLASSWITHBUFFER_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        (*regs)[0] = &v1_;
        (*regs)[1] = &v2_;
        return 2;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        (*regs)[0] = &v1_;
        (*regs)[1] = &v2_;
        return 2;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::DEPRECATED_DEFINECLASSWITHBUFFER;
        ins->regs.reserve(2);
        ins->imms.reserve(2);
        ins->ids.reserve(1);
        ins->regs.emplace_back(v1_);
        ins->regs.emplace_back(v2_);
        ins->imms.emplace_back(imm1_);
        ins->imms.emplace_back(imm2_);
        ins->ids.emplace_back(stringId_0_.Mutf8());
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        return 0;
    }


private:
    util::StringView stringId_0_;
    int64_t imm1_;
    int64_t imm2_;
    VReg v1_;
    VReg v2_;
};

class WideLdpatchvar : public IRNode
{
public:
    explicit WideLdpatchvar(const ir::AstNode* node, int64_t imm) : IRNode(node), imm_(imm) {}

    Formats GetFormats() const override {
        return Span<const Format>(WIDE_LDPATCHVAR_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        return 0;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        return 0;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::WIDE_LDPATCHVAR;
        ins->imms.reserve(1);
        ins->imms.emplace_back(imm_);
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        return 0;
    }


private:
    int64_t imm_;
};

class DeprecatedResumegenerator : public IRNode
{
public:
    explicit DeprecatedResumegenerator(const ir::AstNode* node, VReg v) : IRNode(node), v_(v) {}

    Formats GetFormats() const override {
        return Span<const Format>(DEPRECATED_RESUMEGENERATOR_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        (*regs)[0] = &v_;
        return 1;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        (*regs)[0] = &v_;
        return 1;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::DEPRECATED_RESUMEGENERATOR;
        ins->regs.reserve(1);
        ins->regs.emplace_back(v_);
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        return 0;
    }


private:
    VReg v_;
};

class WideStpatchvar : public IRNode
{
public:
    explicit WideStpatchvar(const ir::AstNode* node, int64_t imm) : IRNode(node), imm_(imm) {}

    Formats GetFormats() const override {
        return Span<const Format>(WIDE_STPATCHVAR_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        return 0;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        return 0;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::WIDE_STPATCHVAR;
        ins->imms.reserve(1);
        ins->imms.emplace_back(imm_);
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        return 0;
    }


private:
    int64_t imm_;
};

class DeprecatedGetresumemode : public IRNode
{
public:
    explicit DeprecatedGetresumemode(const ir::AstNode* node, VReg v) : IRNode(node), v_(v) {}

    Formats GetFormats() const override {
        return Span<const Format>(DEPRECATED_GETRESUMEMODE_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        (*regs)[0] = &v_;
        return 1;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        (*regs)[0] = &v_;
        return 1;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::DEPRECATED_GETRESUMEMODE;
        ins->regs.reserve(1);
        ins->regs.emplace_back(v_);
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        return 0;
    }


private:
    VReg v_;
};

class DeprecatedGettemplateobject : public IRNode
{
public:
    explicit DeprecatedGettemplateobject(const ir::AstNode* node, VReg v) : IRNode(node), v_(v) {}

    Formats GetFormats() const override {
        return Span<const Format>(DEPRECATED_GETTEMPLATEOBJECT_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        (*regs)[0] = &v_;
        return 1;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        (*regs)[0] = &v_;
        return 1;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::DEPRECATED_GETTEMPLATEOBJECT;
        ins->regs.reserve(1);
        ins->regs.emplace_back(v_);
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        return 0;
    }


private:
    VReg v_;
};

class DeprecatedDelobjprop : public IRNode
{
public:
    explicit DeprecatedDelobjprop(const ir::AstNode* node, VReg v1, VReg v2) : IRNode(node), v1_(v1), v2_(v2) {}

    Formats GetFormats() const override {
        return Span<const Format>(DEPRECATED_DELOBJPROP_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        (*regs)[0] = &v1_;
        (*regs)[1] = &v2_;
        return 2;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        (*regs)[0] = &v1_;
        (*regs)[1] = &v2_;
        return 2;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::DEPRECATED_DELOBJPROP;
        ins->regs.reserve(2);
        ins->regs.emplace_back(v1_);
        ins->regs.emplace_back(v2_);
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        return 0;
    }


private:
    VReg v1_;
    VReg v2_;
};

class DeprecatedSuspendgenerator : public IRNode
{
public:
    explicit DeprecatedSuspendgenerator(const ir::AstNode* node, VReg v1, VReg v2) : IRNode(node), v1_(v1), v2_(v2) {}

    Formats GetFormats() const override {
        return Span<const Format>(DEPRECATED_SUSPENDGENERATOR_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        (*regs)[0] = &v1_;
        (*regs)[1] = &v2_;
        return 2;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        (*regs)[0] = &v1_;
        (*regs)[1] = &v2_;
        return 2;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::DEPRECATED_SUSPENDGENERATOR;
        ins->regs.reserve(2);
        ins->regs.emplace_back(v1_);
        ins->regs.emplace_back(v2_);
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        return 0;
    }


private:
    VReg v1_;
    VReg v2_;
};

class DeprecatedAsyncfunctionawaituncaught : public IRNode
{
public:
    explicit DeprecatedAsyncfunctionawaituncaught(const ir::AstNode* node, VReg v1, VReg v2) : IRNode(node), v1_(v1), v2_(v2) {}

    Formats GetFormats() const override {
        return Span<const Format>(DEPRECATED_ASYNCFUNCTIONAWAITUNCAUGHT_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        (*regs)[0] = &v1_;
        (*regs)[1] = &v2_;
        return 2;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        (*regs)[0] = &v1_;
        (*regs)[1] = &v2_;
        return 2;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::DEPRECATED_ASYNCFUNCTIONAWAITUNCAUGHT;
        ins->regs.reserve(2);
        ins->regs.emplace_back(v1_);
        ins->regs.emplace_back(v2_);
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        return 0;
    }


private:
    VReg v1_;
    VReg v2_;
};

class DeprecatedCopydataproperties : public IRNode
{
public:
    explicit DeprecatedCopydataproperties(const ir::AstNode* node, VReg v1, VReg v2) : IRNode(node), v1_(v1), v2_(v2) {}

    Formats GetFormats() const override {
        return Span<const Format>(DEPRECATED_COPYDATAPROPERTIES_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        (*regs)[0] = &v1_;
        (*regs)[1] = &v2_;
        return 2;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        (*regs)[0] = &v1_;
        (*regs)[1] = &v2_;
        return 2;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::DEPRECATED_COPYDATAPROPERTIES;
        ins->regs.reserve(2);
        ins->regs.emplace_back(v1_);
        ins->regs.emplace_back(v2_);
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        return 0;
    }


private:
    VReg v1_;
    VReg v2_;
};

class DeprecatedSetobjectwithproto : public IRNode
{
public:
    explicit DeprecatedSetobjectwithproto(const ir::AstNode* node, VReg v1, VReg v2) : IRNode(node), v1_(v1), v2_(v2) {}

    Formats GetFormats() const override {
        return Span<const Format>(DEPRECATED_SETOBJECTWITHPROTO_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        (*regs)[0] = &v1_;
        (*regs)[1] = &v2_;
        return 2;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        (*regs)[0] = &v1_;
        (*regs)[1] = &v2_;
        return 2;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::DEPRECATED_SETOBJECTWITHPROTO;
        ins->regs.reserve(2);
        ins->regs.emplace_back(v1_);
        ins->regs.emplace_back(v2_);
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        return 0;
    }


private:
    VReg v1_;
    VReg v2_;
};

class DeprecatedLdobjbyvalue : public IRNode
{
public:
    explicit DeprecatedLdobjbyvalue(const ir::AstNode* node, VReg v1, VReg v2) : IRNode(node), v1_(v1), v2_(v2) {}

    Formats GetFormats() const override {
        return Span<const Format>(DEPRECATED_LDOBJBYVALUE_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        (*regs)[0] = &v1_;
        (*regs)[1] = &v2_;
        return 2;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        (*regs)[0] = &v1_;
        (*regs)[1] = &v2_;
        return 2;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::DEPRECATED_LDOBJBYVALUE;
        ins->regs.reserve(2);
        ins->regs.emplace_back(v1_);
        ins->regs.emplace_back(v2_);
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        return 0;
    }


private:
    VReg v1_;
    VReg v2_;
};

class DeprecatedLdsuperbyvalue : public IRNode
{
public:
    explicit DeprecatedLdsuperbyvalue(const ir::AstNode* node, VReg v1, VReg v2) : IRNode(node), v1_(v1), v2_(v2) {}

    Formats GetFormats() const override {
        return Span<const Format>(DEPRECATED_LDSUPERBYVALUE_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        (*regs)[0] = &v1_;
        (*regs)[1] = &v2_;
        return 2;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        (*regs)[0] = &v1_;
        (*regs)[1] = &v2_;
        return 2;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::DEPRECATED_LDSUPERBYVALUE;
        ins->regs.reserve(2);
        ins->regs.emplace_back(v1_);
        ins->regs.emplace_back(v2_);
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        return 0;
    }


private:
    VReg v1_;
    VReg v2_;
};

class DeprecatedLdobjbyindex : public IRNode
{
public:
    explicit DeprecatedLdobjbyindex(const ir::AstNode* node, VReg v, int64_t imm) : IRNode(node), v_(v), imm_(imm) {}

    Formats GetFormats() const override {
        return Span<const Format>(DEPRECATED_LDOBJBYINDEX_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        (*regs)[0] = &v_;
        return 1;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        (*regs)[0] = &v_;
        return 1;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::DEPRECATED_LDOBJBYINDEX;
        ins->regs.reserve(1);
        ins->imms.reserve(1);
        ins->regs.emplace_back(v_);
        ins->imms.emplace_back(imm_);
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        return 0;
    }


private:
    VReg v_;
    int64_t imm_;
};

class DeprecatedAsyncfunctionresolve : public IRNode
{
public:
    explicit DeprecatedAsyncfunctionresolve(const ir::AstNode* node, VReg v1, VReg v2, VReg v3) : IRNode(node), v1_(v1), v2_(v2), v3_(v3) {}

    Formats GetFormats() const override {
        return Span<const Format>(DEPRECATED_ASYNCFUNCTIONRESOLVE_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        (*regs)[0] = &v1_;
        (*regs)[1] = &v2_;
        (*regs)[2] = &v3_;
        return 3;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        (*regs)[0] = &v1_;
        (*regs)[1] = &v2_;
        (*regs)[2] = &v3_;
        return 3;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::DEPRECATED_ASYNCFUNCTIONRESOLVE;
        ins->regs.reserve(3);
        ins->regs.emplace_back(v1_);
        ins->regs.emplace_back(v2_);
        ins->regs.emplace_back(v3_);
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        return 0;
    }


private:
    VReg v1_;
    VReg v2_;
    VReg v3_;
};

class DeprecatedAsyncfunctionreject : public IRNode
{
public:
    explicit DeprecatedAsyncfunctionreject(const ir::AstNode* node, VReg v1, VReg v2, VReg v3) : IRNode(node), v1_(v1), v2_(v2), v3_(v3) {}

    Formats GetFormats() const override {
        return Span<const Format>(DEPRECATED_ASYNCFUNCTIONREJECT_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        (*regs)[0] = &v1_;
        (*regs)[1] = &v2_;
        (*regs)[2] = &v3_;
        return 3;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        (*regs)[0] = &v1_;
        (*regs)[1] = &v2_;
        (*regs)[2] = &v3_;
        return 3;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::DEPRECATED_ASYNCFUNCTIONREJECT;
        ins->regs.reserve(3);
        ins->regs.emplace_back(v1_);
        ins->regs.emplace_back(v2_);
        ins->regs.emplace_back(v3_);
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        return 0;
    }


private:
    VReg v1_;
    VReg v2_;
    VReg v3_;
};

class DeprecatedStlexvar : public IRNode
{
public:
    explicit DeprecatedStlexvar(const ir::AstNode* node, int64_t imm1, int64_t imm2, VReg v) : IRNode(node), imm1_(imm1), imm2_(imm2), v_(v) {}

    Formats GetFormats() const override {
        return Span<const Format>(DEPRECATED_STLEXVAR_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        (*regs)[0] = &v_;
        return 1;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        (*regs)[0] = &v_;
        return 1;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::DEPRECATED_STLEXVAR;
        ins->regs.reserve(1);
        ins->imms.reserve(2);
        ins->regs.emplace_back(v_);
        ins->imms.emplace_back(imm1_);
        ins->imms.emplace_back(imm2_);
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        return 0;
    }


private:
    int64_t imm1_;
    int64_t imm2_;
    VReg v_;
};

class DeprecatedGetmodulenamespace : public IRNode
{
public:
    explicit DeprecatedGetmodulenamespace(const ir::AstNode* node, util::StringView stringId_0) : IRNode(node), stringId_0_(stringId_0) {}

    Formats GetFormats() const override {
        return Span<const Format>(DEPRECATED_GETMODULENAMESPACE_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        return 0;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        return 0;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::DEPRECATED_GETMODULENAMESPACE;
        ins->ids.reserve(1);
        ins->ids.emplace_back(stringId_0_.Mutf8());
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        return 0;
    }


private:
    util::StringView stringId_0_;
};

class DeprecatedStmodulevar : public IRNode
{
public:
    explicit DeprecatedStmodulevar(const ir::AstNode* node, util::StringView stringId_0) : IRNode(node), stringId_0_(stringId_0) {}

    Formats GetFormats() const override {
        return Span<const Format>(DEPRECATED_STMODULEVAR_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        return 0;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        return 0;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::DEPRECATED_STMODULEVAR;
        ins->ids.reserve(1);
        ins->ids.emplace_back(stringId_0_.Mutf8());
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        return 0;
    }


private:
    util::StringView stringId_0_;
};

class DeprecatedLdobjbyname : public IRNode
{
public:
    explicit DeprecatedLdobjbyname(const ir::AstNode* node, util::StringView stringId_0, VReg v) : IRNode(node), stringId_0_(stringId_0), v_(v) {}

    Formats GetFormats() const override {
        return Span<const Format>(DEPRECATED_LDOBJBYNAME_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        (*regs)[0] = &v_;
        return 1;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        (*regs)[0] = &v_;
        return 1;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::DEPRECATED_LDOBJBYNAME;
        ins->regs.reserve(1);
        ins->ids.reserve(1);
        ins->regs.emplace_back(v_);
        ins->ids.emplace_back(stringId_0_.Mutf8());
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        return 0;
    }


private:
    util::StringView stringId_0_;
    VReg v_;
};

class DeprecatedLdsuperbyname : public IRNode
{
public:
    explicit DeprecatedLdsuperbyname(const ir::AstNode* node, util::StringView stringId_0, VReg v) : IRNode(node), stringId_0_(stringId_0), v_(v) {}

    Formats GetFormats() const override {
        return Span<const Format>(DEPRECATED_LDSUPERBYNAME_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        (*regs)[0] = &v_;
        return 1;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        (*regs)[0] = &v_;
        return 1;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::DEPRECATED_LDSUPERBYNAME;
        ins->regs.reserve(1);
        ins->ids.reserve(1);
        ins->regs.emplace_back(v_);
        ins->ids.emplace_back(stringId_0_.Mutf8());
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        return 0;
    }


private:
    util::StringView stringId_0_;
    VReg v_;
};

class DeprecatedLdmodulevar : public IRNode
{
public:
    explicit DeprecatedLdmodulevar(const ir::AstNode* node, util::StringView stringId_0, int64_t imm) : IRNode(node), stringId_0_(stringId_0), imm_(imm) {}

    Formats GetFormats() const override {
        return Span<const Format>(DEPRECATED_LDMODULEVAR_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        return 0;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        return 0;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::DEPRECATED_LDMODULEVAR;
        ins->imms.reserve(1);
        ins->ids.reserve(1);
        ins->imms.emplace_back(imm_);
        ins->ids.emplace_back(stringId_0_.Mutf8());
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        return 0;
    }


private:
    util::StringView stringId_0_;
    int64_t imm_;
};

class DeprecatedStconsttoglobalrecord : public IRNode
{
public:
    explicit DeprecatedStconsttoglobalrecord(const ir::AstNode* node, util::StringView stringId_0) : IRNode(node), stringId_0_(stringId_0) {}

    Formats GetFormats() const override {
        return Span<const Format>(DEPRECATED_STCONSTTOGLOBALRECORD_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        return 0;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        return 0;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::DEPRECATED_STCONSTTOGLOBALRECORD;
        ins->ids.reserve(1);
        ins->ids.emplace_back(stringId_0_.Mutf8());
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        return 0;
    }


private:
    util::StringView stringId_0_;
};

class DeprecatedStlettoglobalrecord : public IRNode
{
public:
    explicit DeprecatedStlettoglobalrecord(const ir::AstNode* node, util::StringView stringId_0) : IRNode(node), stringId_0_(stringId_0) {}

    Formats GetFormats() const override {
        return Span<const Format>(DEPRECATED_STLETTOGLOBALRECORD_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        return 0;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        return 0;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::DEPRECATED_STLETTOGLOBALRECORD;
        ins->ids.reserve(1);
        ins->ids.emplace_back(stringId_0_.Mutf8());
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        return 0;
    }


private:
    util::StringView stringId_0_;
};

class DeprecatedStclasstoglobalrecord : public IRNode
{
public:
    explicit DeprecatedStclasstoglobalrecord(const ir::AstNode* node, util::StringView stringId_0) : IRNode(node), stringId_0_(stringId_0) {}

    Formats GetFormats() const override {
        return Span<const Format>(DEPRECATED_STCLASSTOGLOBALRECORD_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        return 0;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        return 0;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::DEPRECATED_STCLASSTOGLOBALRECORD;
        ins->ids.reserve(1);
        ins->ids.emplace_back(stringId_0_.Mutf8());
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        return 0;
    }


private:
    util::StringView stringId_0_;
};

class DeprecatedLdhomeobject : public IRNode
{
public:
    explicit DeprecatedLdhomeobject(const ir::AstNode* node) : IRNode(node) {}

    Formats GetFormats() const override {
        return Span<const Format>(DEPRECATED_LDHOMEOBJECT_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        return 0;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        return 0;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::DEPRECATED_LDHOMEOBJECT;
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        return 0;
    }


};

class DeprecatedCreateobjecthavingmethod : public IRNode
{
public:
    explicit DeprecatedCreateobjecthavingmethod(const ir::AstNode* node, int64_t imm) : IRNode(node), imm_(imm) {}

    Formats GetFormats() const override {
        return Span<const Format>(DEPRECATED_CREATEOBJECTHAVINGMETHOD_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        return 0;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        return 0;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::DEPRECATED_CREATEOBJECTHAVINGMETHOD;
        ins->imms.reserve(1);
        ins->imms.emplace_back(imm_);
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        return 0;
    }


private:
    int64_t imm_;
};

class DeprecatedDynamicimport : public IRNode
{
public:
    explicit DeprecatedDynamicimport(const ir::AstNode* node, VReg v) : IRNode(node), v_(v) {}

    Formats GetFormats() const override {
        return Span<const Format>(DEPRECATED_DYNAMICIMPORT_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        (*regs)[0] = &v_;
        return 1;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        (*regs)[0] = &v_;
        return 1;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::DEPRECATED_DYNAMICIMPORT;
        ins->regs.reserve(1);
        ins->regs.emplace_back(v_);
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        return 0;
    }


private:
    VReg v_;
};

class DeprecatedAsyncgeneratorreject : public IRNode
{
public:
    explicit DeprecatedAsyncgeneratorreject(const ir::AstNode* node, VReg v1, VReg v2) : IRNode(node), v1_(v1), v2_(v2) {}

    Formats GetFormats() const override {
        return Span<const Format>(DEPRECATED_ASYNCGENERATORREJECT_FORMATS);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        (*regs)[0] = &v1_;
        (*regs)[1] = &v2_;
        return 2;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        (*regs)[0] = &v1_;
        (*regs)[1] = &v2_;
        return 2;
    }

    void Transform(pandasm::Ins* ins) const override
    {
        ins->opcode = pandasm::Opcode::DEPRECATED_ASYNCGENERATORREJECT;
        ins->regs.reserve(2);
        ins->regs.emplace_back(v1_);
        ins->regs.emplace_back(v2_);
    }

    ICSlot SetIcSlot(IcSizeType slot) override
    {
        return 0;
    }


private:
    VReg v1_;
    VReg v2_;
};

}  // namespace panda::es2panda::compiler

#endif
