/**
 * Copyright (c) 2021-2022 Huawei Device Co., Ltd.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Autogenerated file -- DO NOT EDIT!

#include <gen/keywordsMap.h>
#include <lexer/keywordsUtil.h>
#include <lexer/token/letters.h>
#include <macros.h>
#include <utils/span.h>

namespace panda::es2panda::lexer {

class Keywords {
public:
    explicit Keywords(Lexer* lexer, lexer::LexerNextTokenFlags flags) : util_(KeywordsUtil(lexer, flags)) {}
    NO_COPY_SEMANTIC(Keywords);
    NO_MOVE_SEMANTIC(Keywords);
    ~Keywords() = default;

    KeywordsUtil &Util() {
        return util_;
    }

    // NOLINTNEXTLINE(readability-function-size)
    static void SetKeyword(KeywordsUtil *util, const KeywordString& kws) {
        switch(kws.keywordType) {
        case TokenType::KEYW_ABSTRACT: {
            return util->SetKeyword<TokenType::KEYW_ABSTRACT>(kws.str, kws.tokenType);
        }
        case TokenType::KEYW_ANY: {
            return util->SetKeyword<TokenType::KEYW_ANY>(kws.str, kws.tokenType);
        }
        case TokenType::KEYW_ARGUMENTS: {
            return util->SetKeyword<TokenType::KEYW_ARGUMENTS>(kws.str, kws.tokenType);
        }
        case TokenType::KEYW_AS: {
            return util->SetKeyword<TokenType::KEYW_AS>(kws.str, kws.tokenType);
        }
        case TokenType::KEYW_ASSERTS: {
            return util->SetKeyword<TokenType::KEYW_ASSERTS>(kws.str, kws.tokenType);
        }
        case TokenType::KEYW_ASYNC: {
            return util->SetKeyword<TokenType::KEYW_ASYNC>(kws.str, kws.tokenType);
        }
        case TokenType::KEYW_AWAIT: {
            return util->SetKeyword<TokenType::KEYW_AWAIT>(kws.str, kws.tokenType);
        }
        case TokenType::KEYW_BIGINT: {
            return util->SetKeyword<TokenType::KEYW_BIGINT>(kws.str, kws.tokenType);
        }
        case TokenType::KEYW_BOOLEAN: {
            return util->SetKeyword<TokenType::KEYW_BOOLEAN>(kws.str, kws.tokenType);
        }
        case TokenType::KEYW_BREAK: {
            return util->SetKeyword<TokenType::KEYW_BREAK>(kws.str, kws.tokenType);
        }
        case TokenType::KEYW_CASE: {
            return util->SetKeyword<TokenType::KEYW_CASE>(kws.str, kws.tokenType);
        }
        case TokenType::KEYW_CATCH: {
            return util->SetKeyword<TokenType::KEYW_CATCH>(kws.str, kws.tokenType);
        }
        case TokenType::KEYW_CLASS: {
            return util->SetKeyword<TokenType::KEYW_CLASS>(kws.str, kws.tokenType);
        }
        case TokenType::KEYW_CONST: {
            return util->SetKeyword<TokenType::KEYW_CONST>(kws.str, kws.tokenType);
        }
        case TokenType::KEYW_CONTINUE: {
            return util->SetKeyword<TokenType::KEYW_CONTINUE>(kws.str, kws.tokenType);
        }
        case TokenType::KEYW_DEBUGGER: {
            return util->SetKeyword<TokenType::KEYW_DEBUGGER>(kws.str, kws.tokenType);
        }
        case TokenType::KEYW_DECLARE: {
            return util->SetKeyword<TokenType::KEYW_DECLARE>(kws.str, kws.tokenType);
        }
        case TokenType::KEYW_DEFAULT: {
            return util->SetKeyword<TokenType::KEYW_DEFAULT>(kws.str, kws.tokenType);
        }
        case TokenType::KEYW_DELETE: {
            return util->SetKeyword<TokenType::KEYW_DELETE>(kws.str, kws.tokenType);
        }
        case TokenType::KEYW_DO: {
            return util->SetKeyword<TokenType::KEYW_DO>(kws.str, kws.tokenType);
        }
        case TokenType::KEYW_ELSE: {
            return util->SetKeyword<TokenType::KEYW_ELSE>(kws.str, kws.tokenType);
        }
        case TokenType::KEYW_ENUM: {
            return util->SetKeyword<TokenType::KEYW_ENUM>(kws.str, kws.tokenType);
        }
        case TokenType::KEYW_EVAL: {
            return util->SetKeyword<TokenType::KEYW_EVAL>(kws.str, kws.tokenType);
        }
        case TokenType::KEYW_EXPORT: {
            return util->SetKeyword<TokenType::KEYW_EXPORT>(kws.str, kws.tokenType);
        }
        case TokenType::KEYW_EXTENDS: {
            return util->SetKeyword<TokenType::KEYW_EXTENDS>(kws.str, kws.tokenType);
        }
        case TokenType::LITERAL_FALSE: {
            return util->SetKeyword<TokenType::LITERAL_FALSE>(kws.str, kws.tokenType);
        }
        case TokenType::KEYW_FINALLY: {
            return util->SetKeyword<TokenType::KEYW_FINALLY>(kws.str, kws.tokenType);
        }
        case TokenType::KEYW_FOR: {
            return util->SetKeyword<TokenType::KEYW_FOR>(kws.str, kws.tokenType);
        }
        case TokenType::KEYW_FROM: {
            return util->SetKeyword<TokenType::KEYW_FROM>(kws.str, kws.tokenType);
        }
        case TokenType::KEYW_FUNCTION: {
            return util->SetKeyword<TokenType::KEYW_FUNCTION>(kws.str, kws.tokenType);
        }
        case TokenType::KEYW_GET: {
            return util->SetKeyword<TokenType::KEYW_GET>(kws.str, kws.tokenType);
        }
        case TokenType::KEYW_GLOBAL: {
            return util->SetKeyword<TokenType::KEYW_GLOBAL>(kws.str, kws.tokenType);
        }
        case TokenType::KEYW_IF: {
            return util->SetKeyword<TokenType::KEYW_IF>(kws.str, kws.tokenType);
        }
        case TokenType::KEYW_IMPLEMENTS: {
            return util->SetKeyword<TokenType::KEYW_IMPLEMENTS>(kws.str, kws.tokenType);
        }
        case TokenType::KEYW_IMPORT: {
            return util->SetKeyword<TokenType::KEYW_IMPORT>(kws.str, kws.tokenType);
        }
        case TokenType::KEYW_IN: {
            return util->SetKeyword<TokenType::KEYW_IN>(kws.str, kws.tokenType);
        }
        case TokenType::KEYW_INFER: {
            return util->SetKeyword<TokenType::KEYW_INFER>(kws.str, kws.tokenType);
        }
        case TokenType::KEYW_INSTANCEOF: {
            return util->SetKeyword<TokenType::KEYW_INSTANCEOF>(kws.str, kws.tokenType);
        }
        case TokenType::KEYW_INTERFACE: {
            return util->SetKeyword<TokenType::KEYW_INTERFACE>(kws.str, kws.tokenType);
        }
        case TokenType::KEYW_IS: {
            return util->SetKeyword<TokenType::KEYW_IS>(kws.str, kws.tokenType);
        }
        case TokenType::KEYW_KEYOF: {
            return util->SetKeyword<TokenType::KEYW_KEYOF>(kws.str, kws.tokenType);
        }
        case TokenType::KEYW_LET: {
            return util->SetKeyword<TokenType::KEYW_LET>(kws.str, kws.tokenType);
        }
        case TokenType::KEYW_META: {
            return util->SetKeyword<TokenType::KEYW_META>(kws.str, kws.tokenType);
        }
        case TokenType::KEYW_MODULE: {
            return util->SetKeyword<TokenType::KEYW_MODULE>(kws.str, kws.tokenType);
        }
        case TokenType::KEYW_NAMESPACE: {
            return util->SetKeyword<TokenType::KEYW_NAMESPACE>(kws.str, kws.tokenType);
        }
        case TokenType::KEYW_NEVER: {
            return util->SetKeyword<TokenType::KEYW_NEVER>(kws.str, kws.tokenType);
        }
        case TokenType::KEYW_NEW: {
            return util->SetKeyword<TokenType::KEYW_NEW>(kws.str, kws.tokenType);
        }
        case TokenType::LITERAL_NULL: {
            return util->SetKeyword<TokenType::LITERAL_NULL>(kws.str, kws.tokenType);
        }
        case TokenType::KEYW_NUMBER: {
            return util->SetKeyword<TokenType::KEYW_NUMBER>(kws.str, kws.tokenType);
        }
        case TokenType::KEYW_OBJECT: {
            return util->SetKeyword<TokenType::KEYW_OBJECT>(kws.str, kws.tokenType);
        }
        case TokenType::KEYW_OF: {
            return util->SetKeyword<TokenType::KEYW_OF>(kws.str, kws.tokenType);
        }
        case TokenType::KEYW_PACKAGE: {
            return util->SetKeyword<TokenType::KEYW_PACKAGE>(kws.str, kws.tokenType);
        }
        case TokenType::KEYW_PRIVATE: {
            return util->SetKeyword<TokenType::KEYW_PRIVATE>(kws.str, kws.tokenType);
        }
        case TokenType::KEYW_PROTECTED: {
            return util->SetKeyword<TokenType::KEYW_PROTECTED>(kws.str, kws.tokenType);
        }
        case TokenType::KEYW_PUBLIC: {
            return util->SetKeyword<TokenType::KEYW_PUBLIC>(kws.str, kws.tokenType);
        }
        case TokenType::KEYW_READONLY: {
            return util->SetKeyword<TokenType::KEYW_READONLY>(kws.str, kws.tokenType);
        }
        case TokenType::KEYW_RETURN: {
            return util->SetKeyword<TokenType::KEYW_RETURN>(kws.str, kws.tokenType);
        }
        case TokenType::KEYW_REQUIRE: {
            return util->SetKeyword<TokenType::KEYW_REQUIRE>(kws.str, kws.tokenType);
        }
        case TokenType::KEYW_SET: {
            return util->SetKeyword<TokenType::KEYW_SET>(kws.str, kws.tokenType);
        }
        case TokenType::KEYW_STATIC: {
            return util->SetKeyword<TokenType::KEYW_STATIC>(kws.str, kws.tokenType);
        }
        case TokenType::KEYW_STRING: {
            return util->SetKeyword<TokenType::KEYW_STRING>(kws.str, kws.tokenType);
        }
        case TokenType::KEYW_SUPER: {
            return util->SetKeyword<TokenType::KEYW_SUPER>(kws.str, kws.tokenType);
        }
        case TokenType::KEYW_SWITCH: {
            return util->SetKeyword<TokenType::KEYW_SWITCH>(kws.str, kws.tokenType);
        }
        case TokenType::KEYW_SYMBOL: {
            return util->SetKeyword<TokenType::KEYW_SYMBOL>(kws.str, kws.tokenType);
        }
        case TokenType::KEYW_THIS: {
            return util->SetKeyword<TokenType::KEYW_THIS>(kws.str, kws.tokenType);
        }
        case TokenType::KEYW_THROW: {
            return util->SetKeyword<TokenType::KEYW_THROW>(kws.str, kws.tokenType);
        }
        case TokenType::LITERAL_TRUE: {
            return util->SetKeyword<TokenType::LITERAL_TRUE>(kws.str, kws.tokenType);
        }
        case TokenType::KEYW_TRY: {
            return util->SetKeyword<TokenType::KEYW_TRY>(kws.str, kws.tokenType);
        }
        case TokenType::KEYW_TYPE: {
            return util->SetKeyword<TokenType::KEYW_TYPE>(kws.str, kws.tokenType);
        }
        case TokenType::KEYW_TYPEOF: {
            return util->SetKeyword<TokenType::KEYW_TYPEOF>(kws.str, kws.tokenType);
        }
        case TokenType::KEYW_UNDEFINED: {
            return util->SetKeyword<TokenType::KEYW_UNDEFINED>(kws.str, kws.tokenType);
        }
        case TokenType::KEYW_UNIQUE: {
            return util->SetKeyword<TokenType::KEYW_UNIQUE>(kws.str, kws.tokenType);
        }
        case TokenType::KEYW_UNKNOWN: {
            return util->SetKeyword<TokenType::KEYW_UNKNOWN>(kws.str, kws.tokenType);
        }
        case TokenType::KEYW_VAR: {
            return util->SetKeyword<TokenType::KEYW_VAR>(kws.str, kws.tokenType);
        }
        case TokenType::KEYW_VOID: {
            return util->SetKeyword<TokenType::KEYW_VOID>(kws.str, kws.tokenType);
        }
        case TokenType::KEYW_WHILE: {
            return util->SetKeyword<TokenType::KEYW_WHILE>(kws.str, kws.tokenType);
        }
        case TokenType::KEYW_WITH: {
            return util->SetKeyword<TokenType::KEYW_WITH>(kws.str, kws.tokenType);
        }
        case TokenType::KEYW_YIELD: {
            return util->SetKeyword<TokenType::KEYW_YIELD>(kws.str, kws.tokenType);
        }
        default: {
            break;
        }
        }
    }

    inline void ScanA()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_B: /* 'b' */ {
            util_.Iterator().Forward(1);
            ScanAB();
            return;
        }
        case LEX_CHAR_LOWERCASE_N: /* 'n' */ {
            util_.Iterator().Forward(1);
            ScanAN();
            return;
        }
        case LEX_CHAR_LOWERCASE_R: /* 'r' */ {
            util_.Iterator().Forward(1);
            ScanAR();
            return;
        }
        case LEX_CHAR_LOWERCASE_S: /* 's' */ {
            util_.Iterator().Forward(1);
            ScanAS();
            return;
        }
        case LEX_CHAR_LOWERCASE_W: /* 'w' */ {
            util_.Iterator().Forward(1);
            ScanAW();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_A));
    }

    inline void ScanAB()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_S: /* 's' */ {
            util_.Iterator().Forward(1);
            ScanABS();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_A));
    }

    inline void ScanAN()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_Y: /* 'y' */ {
            util_.Iterator().Forward(1);
            ScanANY();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_A));
    }

    inline void ScanAR()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_G: /* 'g' */ {
            util_.Iterator().Forward(1);
            ScanARG();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_A));
    }

    inline void ScanAS()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_S: /* 's' */ {
            util_.Iterator().Forward(1);
            ScanASS();
            return;
        }
        case LEX_CHAR_LOWERCASE_Y: /* 'y' */ {
            util_.Iterator().Forward(1);
            ScanASY();
            return;
        }
        default: {
            if (!KeywordsUtil::IsIdentifierPart(util_.Iterator().PeekCp())) {
                util_.SetKeyword<TokenType::KEYW_AS>("as", TokenType::LITERAL_IDENT);
                return;
            }
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_A));
    }

    inline void ScanAW()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_A: /* 'a' */ {
            util_.Iterator().Forward(1);
            ScanAWA();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_A));
    }

    inline void ScanABS()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_T: /* 't' */ {
            util_.Iterator().Forward(1);
            ScanABST();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_A));
    }

    inline void ScanANY()
    {
        switch(util_.Iterator().Peek()) {
        default: {
            if (!KeywordsUtil::IsIdentifierPart(util_.Iterator().PeekCp())) {
                util_.SetKeyword<TokenType::KEYW_ANY>("any", TokenType::LITERAL_IDENT);
                return;
            }
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_A));
    }

    inline void ScanARG()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_U: /* 'u' */ {
            util_.Iterator().Forward(1);
            ScanARGU();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_A));
    }

    inline void ScanASS()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_E: /* 'e' */ {
            util_.Iterator().Forward(1);
            ScanASSE();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_A));
    }

    inline void ScanASY()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_N: /* 'n' */ {
            util_.Iterator().Forward(1);
            ScanASYN();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_A));
    }

    inline void ScanAWA()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_I: /* 'i' */ {
            util_.Iterator().Forward(1);
            ScanAWAI();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_A));
    }

    inline void ScanABST()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_R: /* 'r' */ {
            util_.Iterator().Forward(1);
            ScanABSTR();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_A));
    }

    inline void ScanARGU()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_M: /* 'm' */ {
            util_.Iterator().Forward(1);
            ScanARGUM();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_A));
    }

    inline void ScanASSE()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_R: /* 'r' */ {
            util_.Iterator().Forward(1);
            ScanASSER();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_A));
    }

    inline void ScanASYN()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_C: /* 'c' */ {
            util_.Iterator().Forward(1);
            ScanASYNC();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_A));
    }

    inline void ScanAWAI()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_T: /* 't' */ {
            util_.Iterator().Forward(1);
            ScanAWAIT();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_A));
    }

    inline void ScanABSTR()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_A: /* 'a' */ {
            util_.Iterator().Forward(1);
            ScanABSTRA();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_A));
    }

    inline void ScanARGUM()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_E: /* 'e' */ {
            util_.Iterator().Forward(1);
            ScanARGUME();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_A));
    }

    inline void ScanASSER()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_T: /* 't' */ {
            util_.Iterator().Forward(1);
            ScanASSERT();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_A));
    }

    inline void ScanASYNC()
    {
        switch(util_.Iterator().Peek()) {
        default: {
            if (!KeywordsUtil::IsIdentifierPart(util_.Iterator().PeekCp())) {
                util_.SetKeyword<TokenType::KEYW_ASYNC>("async", TokenType::LITERAL_IDENT);
                return;
            }
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_A));
    }

    inline void ScanAWAIT()
    {
        switch(util_.Iterator().Peek()) {
        default: {
            if (!KeywordsUtil::IsIdentifierPart(util_.Iterator().PeekCp())) {
                util_.SetKeyword<TokenType::KEYW_AWAIT>("await", TokenType::LITERAL_IDENT);
                return;
            }
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_A));
    }

    inline void ScanABSTRA()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_C: /* 'c' */ {
            util_.Iterator().Forward(1);
            ScanABSTRAC();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_A));
    }

    inline void ScanARGUME()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_N: /* 'n' */ {
            util_.Iterator().Forward(1);
            ScanARGUMEN();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_A));
    }

    inline void ScanASSERT()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_S: /* 's' */ {
            util_.Iterator().Forward(1);
            ScanASSERTS();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_A));
    }

    inline void ScanABSTRAC()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_T: /* 't' */ {
            util_.Iterator().Forward(1);
            ScanABSTRACT();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_A));
    }

    inline void ScanARGUMEN()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_T: /* 't' */ {
            util_.Iterator().Forward(1);
            ScanARGUMENT();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_A));
    }

    inline void ScanASSERTS()
    {
        switch(util_.Iterator().Peek()) {
        default: {
            if (!KeywordsUtil::IsIdentifierPart(util_.Iterator().PeekCp())) {
                util_.SetKeyword<TokenType::KEYW_ASSERTS>("asserts", TokenType::LITERAL_IDENT);
                return;
            }
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_A));
    }

    inline void ScanABSTRACT()
    {
        switch(util_.Iterator().Peek()) {
        default: {
            if (!KeywordsUtil::IsIdentifierPart(util_.Iterator().PeekCp())) {
                util_.SetKeyword<TokenType::KEYW_ABSTRACT>("abstract", TokenType::LITERAL_IDENT);
                return;
            }
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_A));
    }

    inline void ScanARGUMENT()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_S: /* 's' */ {
            util_.Iterator().Forward(1);
            ScanARGUMENTS();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_A));
    }

    inline void ScanARGUMENTS()
    {
        switch(util_.Iterator().Peek()) {
        default: {
            if (!KeywordsUtil::IsIdentifierPart(util_.Iterator().PeekCp())) {
                util_.SetKeyword<TokenType::KEYW_ARGUMENTS>("arguments", TokenType::LITERAL_IDENT);
                return;
            }
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_A));
    }

    inline void ScanB()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_I: /* 'i' */ {
            util_.Iterator().Forward(1);
            ScanBI();
            return;
        }
        case LEX_CHAR_LOWERCASE_O: /* 'o' */ {
            util_.Iterator().Forward(1);
            ScanBO();
            return;
        }
        case LEX_CHAR_LOWERCASE_R: /* 'r' */ {
            util_.Iterator().Forward(1);
            ScanBR();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_B));
    }

    inline void ScanBI()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_G: /* 'g' */ {
            util_.Iterator().Forward(1);
            ScanBIG();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_B));
    }

    inline void ScanBO()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_O: /* 'o' */ {
            util_.Iterator().Forward(1);
            ScanBOO();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_B));
    }

    inline void ScanBR()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_E: /* 'e' */ {
            util_.Iterator().Forward(1);
            ScanBRE();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_B));
    }

    inline void ScanBIG()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_I: /* 'i' */ {
            util_.Iterator().Forward(1);
            ScanBIGI();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_B));
    }

    inline void ScanBOO()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_L: /* 'l' */ {
            util_.Iterator().Forward(1);
            ScanBOOL();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_B));
    }

    inline void ScanBRE()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_A: /* 'a' */ {
            util_.Iterator().Forward(1);
            ScanBREA();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_B));
    }

    inline void ScanBIGI()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_N: /* 'n' */ {
            util_.Iterator().Forward(1);
            ScanBIGIN();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_B));
    }

    inline void ScanBOOL()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_E: /* 'e' */ {
            util_.Iterator().Forward(1);
            ScanBOOLE();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_B));
    }

    inline void ScanBREA()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_K: /* 'k' */ {
            util_.Iterator().Forward(1);
            ScanBREAK();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_B));
    }

    inline void ScanBIGIN()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_T: /* 't' */ {
            util_.Iterator().Forward(1);
            ScanBIGINT();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_B));
    }

    inline void ScanBOOLE()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_A: /* 'a' */ {
            util_.Iterator().Forward(1);
            ScanBOOLEA();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_B));
    }

    inline void ScanBREAK()
    {
        switch(util_.Iterator().Peek()) {
        default: {
            if (!KeywordsUtil::IsIdentifierPart(util_.Iterator().PeekCp())) {
                util_.SetKeyword<TokenType::KEYW_BREAK>("break", TokenType::KEYW_BREAK);
                return;
            }
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_B));
    }

    inline void ScanBIGINT()
    {
        switch(util_.Iterator().Peek()) {
        default: {
            if (!KeywordsUtil::IsIdentifierPart(util_.Iterator().PeekCp())) {
                util_.SetKeyword<TokenType::KEYW_BIGINT>("bigint", TokenType::LITERAL_IDENT);
                return;
            }
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_B));
    }

    inline void ScanBOOLEA()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_N: /* 'n' */ {
            util_.Iterator().Forward(1);
            ScanBOOLEAN();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_B));
    }

    inline void ScanBOOLEAN()
    {
        switch(util_.Iterator().Peek()) {
        default: {
            if (!KeywordsUtil::IsIdentifierPart(util_.Iterator().PeekCp())) {
                util_.SetKeyword<TokenType::KEYW_BOOLEAN>("boolean", TokenType::LITERAL_IDENT);
                return;
            }
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_B));
    }

    inline void ScanC()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_A: /* 'a' */ {
            util_.Iterator().Forward(1);
            ScanCA();
            return;
        }
        case LEX_CHAR_LOWERCASE_L: /* 'l' */ {
            util_.Iterator().Forward(1);
            ScanCL();
            return;
        }
        case LEX_CHAR_LOWERCASE_O: /* 'o' */ {
            util_.Iterator().Forward(1);
            ScanCO();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_C));
    }

    inline void ScanCA()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_S: /* 's' */ {
            util_.Iterator().Forward(1);
            ScanCAS();
            return;
        }
        case LEX_CHAR_LOWERCASE_T: /* 't' */ {
            util_.Iterator().Forward(1);
            ScanCAT();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_C));
    }

    inline void ScanCL()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_A: /* 'a' */ {
            util_.Iterator().Forward(1);
            ScanCLA();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_C));
    }

    inline void ScanCO()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_N: /* 'n' */ {
            util_.Iterator().Forward(1);
            ScanCON();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_C));
    }

    inline void ScanCAS()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_E: /* 'e' */ {
            util_.Iterator().Forward(1);
            ScanCASE();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_C));
    }

    inline void ScanCAT()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_C: /* 'c' */ {
            util_.Iterator().Forward(1);
            ScanCATC();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_C));
    }

    inline void ScanCLA()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_S: /* 's' */ {
            util_.Iterator().Forward(1);
            ScanCLAS();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_C));
    }

    inline void ScanCON()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_S: /* 's' */ {
            util_.Iterator().Forward(1);
            ScanCONS();
            return;
        }
        case LEX_CHAR_LOWERCASE_T: /* 't' */ {
            util_.Iterator().Forward(1);
            ScanCONT();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_C));
    }

    inline void ScanCASE()
    {
        switch(util_.Iterator().Peek()) {
        default: {
            if (!KeywordsUtil::IsIdentifierPart(util_.Iterator().PeekCp())) {
                util_.SetKeyword<TokenType::KEYW_CASE>("case", TokenType::KEYW_CASE);
                return;
            }
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_C));
    }

    inline void ScanCATC()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_H: /* 'h' */ {
            util_.Iterator().Forward(1);
            ScanCATCH();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_C));
    }

    inline void ScanCLAS()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_S: /* 's' */ {
            util_.Iterator().Forward(1);
            ScanCLASS();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_C));
    }

    inline void ScanCONS()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_T: /* 't' */ {
            util_.Iterator().Forward(1);
            ScanCONST();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_C));
    }

    inline void ScanCONT()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_I: /* 'i' */ {
            util_.Iterator().Forward(1);
            ScanCONTI();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_C));
    }

    inline void ScanCATCH()
    {
        switch(util_.Iterator().Peek()) {
        default: {
            if (!KeywordsUtil::IsIdentifierPart(util_.Iterator().PeekCp())) {
                util_.SetKeyword<TokenType::KEYW_CATCH>("catch", TokenType::KEYW_CATCH);
                return;
            }
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_C));
    }

    inline void ScanCLASS()
    {
        switch(util_.Iterator().Peek()) {
        default: {
            if (!KeywordsUtil::IsIdentifierPart(util_.Iterator().PeekCp())) {
                util_.SetKeyword<TokenType::KEYW_CLASS>("class", TokenType::KEYW_CLASS);
                return;
            }
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_C));
    }

    inline void ScanCONST()
    {
        switch(util_.Iterator().Peek()) {
        default: {
            if (!KeywordsUtil::IsIdentifierPart(util_.Iterator().PeekCp())) {
                util_.SetKeyword<TokenType::KEYW_CONST>("const", TokenType::KEYW_CONST);
                return;
            }
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_C));
    }

    inline void ScanCONTI()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_N: /* 'n' */ {
            util_.Iterator().Forward(1);
            ScanCONTIN();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_C));
    }

    inline void ScanCONTIN()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_U: /* 'u' */ {
            util_.Iterator().Forward(1);
            ScanCONTINU();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_C));
    }

    inline void ScanCONTINU()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_E: /* 'e' */ {
            util_.Iterator().Forward(1);
            ScanCONTINUE();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_C));
    }

    inline void ScanCONTINUE()
    {
        switch(util_.Iterator().Peek()) {
        default: {
            if (!KeywordsUtil::IsIdentifierPart(util_.Iterator().PeekCp())) {
                util_.SetKeyword<TokenType::KEYW_CONTINUE>("continue", TokenType::KEYW_CONTINUE);
                return;
            }
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_C));
    }

    inline void ScanD()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_E: /* 'e' */ {
            util_.Iterator().Forward(1);
            ScanDE();
            return;
        }
        case LEX_CHAR_LOWERCASE_O: /* 'o' */ {
            util_.Iterator().Forward(1);
            ScanDO();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_D));
    }

    inline void ScanDE()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_B: /* 'b' */ {
            util_.Iterator().Forward(1);
            ScanDEB();
            return;
        }
        case LEX_CHAR_LOWERCASE_C: /* 'c' */ {
            util_.Iterator().Forward(1);
            ScanDEC();
            return;
        }
        case LEX_CHAR_LOWERCASE_F: /* 'f' */ {
            util_.Iterator().Forward(1);
            ScanDEF();
            return;
        }
        case LEX_CHAR_LOWERCASE_L: /* 'l' */ {
            util_.Iterator().Forward(1);
            ScanDEL();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_D));
    }

    inline void ScanDO()
    {
        switch(util_.Iterator().Peek()) {
        default: {
            if (!KeywordsUtil::IsIdentifierPart(util_.Iterator().PeekCp())) {
                util_.SetKeyword<TokenType::KEYW_DO>("do", TokenType::KEYW_DO);
                return;
            }
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_D));
    }

    inline void ScanDEB()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_U: /* 'u' */ {
            util_.Iterator().Forward(1);
            ScanDEBU();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_D));
    }

    inline void ScanDEC()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_L: /* 'l' */ {
            util_.Iterator().Forward(1);
            ScanDECL();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_D));
    }

    inline void ScanDEF()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_A: /* 'a' */ {
            util_.Iterator().Forward(1);
            ScanDEFA();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_D));
    }

    inline void ScanDEL()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_E: /* 'e' */ {
            util_.Iterator().Forward(1);
            ScanDELE();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_D));
    }

    inline void ScanDEBU()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_G: /* 'g' */ {
            util_.Iterator().Forward(1);
            ScanDEBUG();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_D));
    }

    inline void ScanDECL()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_A: /* 'a' */ {
            util_.Iterator().Forward(1);
            ScanDECLA();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_D));
    }

    inline void ScanDEFA()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_U: /* 'u' */ {
            util_.Iterator().Forward(1);
            ScanDEFAU();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_D));
    }

    inline void ScanDELE()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_T: /* 't' */ {
            util_.Iterator().Forward(1);
            ScanDELET();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_D));
    }

    inline void ScanDEBUG()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_G: /* 'g' */ {
            util_.Iterator().Forward(1);
            ScanDEBUGG();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_D));
    }

    inline void ScanDECLA()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_R: /* 'r' */ {
            util_.Iterator().Forward(1);
            ScanDECLAR();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_D));
    }

    inline void ScanDEFAU()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_L: /* 'l' */ {
            util_.Iterator().Forward(1);
            ScanDEFAUL();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_D));
    }

    inline void ScanDELET()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_E: /* 'e' */ {
            util_.Iterator().Forward(1);
            ScanDELETE();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_D));
    }

    inline void ScanDEBUGG()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_E: /* 'e' */ {
            util_.Iterator().Forward(1);
            ScanDEBUGGE();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_D));
    }

    inline void ScanDECLAR()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_E: /* 'e' */ {
            util_.Iterator().Forward(1);
            ScanDECLARE();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_D));
    }

    inline void ScanDEFAUL()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_T: /* 't' */ {
            util_.Iterator().Forward(1);
            ScanDEFAULT();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_D));
    }

    inline void ScanDELETE()
    {
        switch(util_.Iterator().Peek()) {
        default: {
            if (!KeywordsUtil::IsIdentifierPart(util_.Iterator().PeekCp())) {
                util_.SetKeyword<TokenType::KEYW_DELETE>("delete", TokenType::KEYW_DELETE);
                return;
            }
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_D));
    }

    inline void ScanDEBUGGE()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_R: /* 'r' */ {
            util_.Iterator().Forward(1);
            ScanDEBUGGER();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_D));
    }

    inline void ScanDECLARE()
    {
        switch(util_.Iterator().Peek()) {
        default: {
            if (!KeywordsUtil::IsIdentifierPart(util_.Iterator().PeekCp())) {
                util_.SetKeyword<TokenType::KEYW_DECLARE>("declare", TokenType::KEYW_DECLARE);
                return;
            }
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_D));
    }

    inline void ScanDEFAULT()
    {
        switch(util_.Iterator().Peek()) {
        default: {
            if (!KeywordsUtil::IsIdentifierPart(util_.Iterator().PeekCp())) {
                util_.SetKeyword<TokenType::KEYW_DEFAULT>("default", TokenType::KEYW_DEFAULT);
                return;
            }
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_D));
    }

    inline void ScanDEBUGGER()
    {
        switch(util_.Iterator().Peek()) {
        default: {
            if (!KeywordsUtil::IsIdentifierPart(util_.Iterator().PeekCp())) {
                util_.SetKeyword<TokenType::KEYW_DEBUGGER>("debugger", TokenType::KEYW_DEBUGGER);
                return;
            }
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_D));
    }

    inline void ScanE()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_L: /* 'l' */ {
            util_.Iterator().Forward(1);
            ScanEL();
            return;
        }
        case LEX_CHAR_LOWERCASE_N: /* 'n' */ {
            util_.Iterator().Forward(1);
            ScanEN();
            return;
        }
        case LEX_CHAR_LOWERCASE_V: /* 'v' */ {
            util_.Iterator().Forward(1);
            ScanEV();
            return;
        }
        case LEX_CHAR_LOWERCASE_X: /* 'x' */ {
            util_.Iterator().Forward(1);
            ScanEX();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_E));
    }

    inline void ScanEL()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_S: /* 's' */ {
            util_.Iterator().Forward(1);
            ScanELS();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_E));
    }

    inline void ScanEN()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_U: /* 'u' */ {
            util_.Iterator().Forward(1);
            ScanENU();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_E));
    }

    inline void ScanEV()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_A: /* 'a' */ {
            util_.Iterator().Forward(1);
            ScanEVA();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_E));
    }

    inline void ScanEX()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_P: /* 'p' */ {
            util_.Iterator().Forward(1);
            ScanEXP();
            return;
        }
        case LEX_CHAR_LOWERCASE_T: /* 't' */ {
            util_.Iterator().Forward(1);
            ScanEXT();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_E));
    }

    inline void ScanELS()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_E: /* 'e' */ {
            util_.Iterator().Forward(1);
            ScanELSE();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_E));
    }

    inline void ScanENU()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_M: /* 'm' */ {
            util_.Iterator().Forward(1);
            ScanENUM();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_E));
    }

    inline void ScanEVA()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_L: /* 'l' */ {
            util_.Iterator().Forward(1);
            ScanEVAL();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_E));
    }

    inline void ScanEXP()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_O: /* 'o' */ {
            util_.Iterator().Forward(1);
            ScanEXPO();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_E));
    }

    inline void ScanEXT()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_E: /* 'e' */ {
            util_.Iterator().Forward(1);
            ScanEXTE();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_E));
    }

    inline void ScanELSE()
    {
        switch(util_.Iterator().Peek()) {
        default: {
            if (!KeywordsUtil::IsIdentifierPart(util_.Iterator().PeekCp())) {
                util_.SetKeyword<TokenType::KEYW_ELSE>("else", TokenType::KEYW_ELSE);
                return;
            }
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_E));
    }

    inline void ScanENUM()
    {
        switch(util_.Iterator().Peek()) {
        default: {
            if (!KeywordsUtil::IsIdentifierPart(util_.Iterator().PeekCp())) {
                util_.SetKeyword<TokenType::KEYW_ENUM>("enum", TokenType::LITERAL_IDENT);
                return;
            }
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_E));
    }

    inline void ScanEVAL()
    {
        switch(util_.Iterator().Peek()) {
        default: {
            if (!KeywordsUtil::IsIdentifierPart(util_.Iterator().PeekCp())) {
                util_.SetKeyword<TokenType::KEYW_EVAL>("eval", TokenType::LITERAL_IDENT);
                return;
            }
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_E));
    }

    inline void ScanEXPO()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_R: /* 'r' */ {
            util_.Iterator().Forward(1);
            ScanEXPOR();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_E));
    }

    inline void ScanEXTE()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_N: /* 'n' */ {
            util_.Iterator().Forward(1);
            ScanEXTEN();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_E));
    }

    inline void ScanEXPOR()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_T: /* 't' */ {
            util_.Iterator().Forward(1);
            ScanEXPORT();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_E));
    }

    inline void ScanEXTEN()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_D: /* 'd' */ {
            util_.Iterator().Forward(1);
            ScanEXTEND();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_E));
    }

    inline void ScanEXPORT()
    {
        switch(util_.Iterator().Peek()) {
        default: {
            if (!KeywordsUtil::IsIdentifierPart(util_.Iterator().PeekCp())) {
                util_.SetKeyword<TokenType::KEYW_EXPORT>("export", TokenType::KEYW_EXPORT);
                return;
            }
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_E));
    }

    inline void ScanEXTEND()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_S: /* 's' */ {
            util_.Iterator().Forward(1);
            ScanEXTENDS();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_E));
    }

    inline void ScanEXTENDS()
    {
        switch(util_.Iterator().Peek()) {
        default: {
            if (!KeywordsUtil::IsIdentifierPart(util_.Iterator().PeekCp())) {
                util_.SetKeyword<TokenType::KEYW_EXTENDS>("extends", TokenType::KEYW_EXTENDS);
                return;
            }
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_E));
    }

    inline void ScanF()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_A: /* 'a' */ {
            util_.Iterator().Forward(1);
            ScanFA();
            return;
        }
        case LEX_CHAR_LOWERCASE_I: /* 'i' */ {
            util_.Iterator().Forward(1);
            ScanFI();
            return;
        }
        case LEX_CHAR_LOWERCASE_O: /* 'o' */ {
            util_.Iterator().Forward(1);
            ScanFO();
            return;
        }
        case LEX_CHAR_LOWERCASE_R: /* 'r' */ {
            util_.Iterator().Forward(1);
            ScanFR();
            return;
        }
        case LEX_CHAR_LOWERCASE_U: /* 'u' */ {
            util_.Iterator().Forward(1);
            ScanFU();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_F));
    }

    inline void ScanFA()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_L: /* 'l' */ {
            util_.Iterator().Forward(1);
            ScanFAL();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_F));
    }

    inline void ScanFI()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_N: /* 'n' */ {
            util_.Iterator().Forward(1);
            ScanFIN();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_F));
    }

    inline void ScanFO()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_R: /* 'r' */ {
            util_.Iterator().Forward(1);
            ScanFOR();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_F));
    }

    inline void ScanFR()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_O: /* 'o' */ {
            util_.Iterator().Forward(1);
            ScanFRO();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_F));
    }

    inline void ScanFU()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_N: /* 'n' */ {
            util_.Iterator().Forward(1);
            ScanFUN();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_F));
    }

    inline void ScanFAL()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_S: /* 's' */ {
            util_.Iterator().Forward(1);
            ScanFALS();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_F));
    }

    inline void ScanFIN()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_A: /* 'a' */ {
            util_.Iterator().Forward(1);
            ScanFINA();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_F));
    }

    inline void ScanFOR()
    {
        switch(util_.Iterator().Peek()) {
        default: {
            if (!KeywordsUtil::IsIdentifierPart(util_.Iterator().PeekCp())) {
                util_.SetKeyword<TokenType::KEYW_FOR>("for", TokenType::KEYW_FOR);
                return;
            }
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_F));
    }

    inline void ScanFRO()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_M: /* 'm' */ {
            util_.Iterator().Forward(1);
            ScanFROM();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_F));
    }

    inline void ScanFUN()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_C: /* 'c' */ {
            util_.Iterator().Forward(1);
            ScanFUNC();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_F));
    }

    inline void ScanFALS()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_E: /* 'e' */ {
            util_.Iterator().Forward(1);
            ScanFALSE();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_F));
    }

    inline void ScanFINA()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_L: /* 'l' */ {
            util_.Iterator().Forward(1);
            ScanFINAL();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_F));
    }

    inline void ScanFROM()
    {
        switch(util_.Iterator().Peek()) {
        default: {
            if (!KeywordsUtil::IsIdentifierPart(util_.Iterator().PeekCp())) {
                util_.SetKeyword<TokenType::KEYW_FROM>("from", TokenType::LITERAL_IDENT);
                return;
            }
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_F));
    }

    inline void ScanFUNC()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_T: /* 't' */ {
            util_.Iterator().Forward(1);
            ScanFUNCT();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_F));
    }

    inline void ScanFALSE()
    {
        switch(util_.Iterator().Peek()) {
        default: {
            if (!KeywordsUtil::IsIdentifierPart(util_.Iterator().PeekCp())) {
                util_.SetKeyword<TokenType::LITERAL_FALSE>("false", TokenType::LITERAL_FALSE);
                return;
            }
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_F));
    }

    inline void ScanFINAL()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_L: /* 'l' */ {
            util_.Iterator().Forward(1);
            ScanFINALL();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_F));
    }

    inline void ScanFUNCT()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_I: /* 'i' */ {
            util_.Iterator().Forward(1);
            ScanFUNCTI();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_F));
    }

    inline void ScanFINALL()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_Y: /* 'y' */ {
            util_.Iterator().Forward(1);
            ScanFINALLY();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_F));
    }

    inline void ScanFUNCTI()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_O: /* 'o' */ {
            util_.Iterator().Forward(1);
            ScanFUNCTIO();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_F));
    }

    inline void ScanFINALLY()
    {
        switch(util_.Iterator().Peek()) {
        default: {
            if (!KeywordsUtil::IsIdentifierPart(util_.Iterator().PeekCp())) {
                util_.SetKeyword<TokenType::KEYW_FINALLY>("finally", TokenType::KEYW_FINALLY);
                return;
            }
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_F));
    }

    inline void ScanFUNCTIO()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_N: /* 'n' */ {
            util_.Iterator().Forward(1);
            ScanFUNCTION();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_F));
    }

    inline void ScanFUNCTION()
    {
        switch(util_.Iterator().Peek()) {
        default: {
            if (!KeywordsUtil::IsIdentifierPart(util_.Iterator().PeekCp())) {
                util_.SetKeyword<TokenType::KEYW_FUNCTION>("function", TokenType::KEYW_FUNCTION);
                return;
            }
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_F));
    }

    inline void ScanG()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_E: /* 'e' */ {
            util_.Iterator().Forward(1);
            ScanGE();
            return;
        }
        case LEX_CHAR_LOWERCASE_L: /* 'l' */ {
            util_.Iterator().Forward(1);
            ScanGL();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_G));
    }

    inline void ScanGE()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_T: /* 't' */ {
            util_.Iterator().Forward(1);
            ScanGET();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_G));
    }

    inline void ScanGL()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_O: /* 'o' */ {
            util_.Iterator().Forward(1);
            ScanGLO();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_G));
    }

    inline void ScanGET()
    {
        switch(util_.Iterator().Peek()) {
        default: {
            if (!KeywordsUtil::IsIdentifierPart(util_.Iterator().PeekCp())) {
                util_.SetKeyword<TokenType::KEYW_GET>("get", TokenType::LITERAL_IDENT);
                return;
            }
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_G));
    }

    inline void ScanGLO()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_B: /* 'b' */ {
            util_.Iterator().Forward(1);
            ScanGLOB();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_G));
    }

    inline void ScanGLOB()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_A: /* 'a' */ {
            util_.Iterator().Forward(1);
            ScanGLOBA();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_G));
    }

    inline void ScanGLOBA()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_L: /* 'l' */ {
            util_.Iterator().Forward(1);
            ScanGLOBAL();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_G));
    }

    inline void ScanGLOBAL()
    {
        switch(util_.Iterator().Peek()) {
        default: {
            if (!KeywordsUtil::IsIdentifierPart(util_.Iterator().PeekCp())) {
                util_.SetKeyword<TokenType::KEYW_GLOBAL>("global", TokenType::LITERAL_IDENT);
                return;
            }
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_G));
    }

    inline void ScanI()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_F: /* 'f' */ {
            util_.Iterator().Forward(1);
            ScanIF();
            return;
        }
        case LEX_CHAR_LOWERCASE_M: /* 'm' */ {
            util_.Iterator().Forward(1);
            ScanIM();
            return;
        }
        case LEX_CHAR_LOWERCASE_N: /* 'n' */ {
            util_.Iterator().Forward(1);
            ScanIN();
            return;
        }
        case LEX_CHAR_LOWERCASE_S: /* 's' */ {
            util_.Iterator().Forward(1);
            ScanIS();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_I));
    }

    inline void ScanIF()
    {
        switch(util_.Iterator().Peek()) {
        default: {
            if (!KeywordsUtil::IsIdentifierPart(util_.Iterator().PeekCp())) {
                util_.SetKeyword<TokenType::KEYW_IF>("if", TokenType::KEYW_IF);
                return;
            }
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_I));
    }

    inline void ScanIM()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_P: /* 'p' */ {
            util_.Iterator().Forward(1);
            ScanIMP();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_I));
    }

    inline void ScanIN()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_F: /* 'f' */ {
            util_.Iterator().Forward(1);
            ScanINF();
            return;
        }
        case LEX_CHAR_LOWERCASE_S: /* 's' */ {
            util_.Iterator().Forward(1);
            ScanINS();
            return;
        }
        case LEX_CHAR_LOWERCASE_T: /* 't' */ {
            util_.Iterator().Forward(1);
            ScanINT();
            return;
        }
        default: {
            if (!KeywordsUtil::IsIdentifierPart(util_.Iterator().PeekCp())) {
                util_.SetKeyword<TokenType::KEYW_IN>("in", TokenType::KEYW_IN);
                return;
            }
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_I));
    }

    inline void ScanIS()
    {
        switch(util_.Iterator().Peek()) {
        default: {
            if (!KeywordsUtil::IsIdentifierPart(util_.Iterator().PeekCp())) {
                util_.SetKeyword<TokenType::KEYW_IS>("is", TokenType::LITERAL_IDENT);
                return;
            }
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_I));
    }

    inline void ScanIMP()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_L: /* 'l' */ {
            util_.Iterator().Forward(1);
            ScanIMPL();
            return;
        }
        case LEX_CHAR_LOWERCASE_O: /* 'o' */ {
            util_.Iterator().Forward(1);
            ScanIMPO();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_I));
    }

    inline void ScanINF()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_E: /* 'e' */ {
            util_.Iterator().Forward(1);
            ScanINFE();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_I));
    }

    inline void ScanINS()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_T: /* 't' */ {
            util_.Iterator().Forward(1);
            ScanINST();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_I));
    }

    inline void ScanINT()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_E: /* 'e' */ {
            util_.Iterator().Forward(1);
            ScanINTE();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_I));
    }

    inline void ScanIMPL()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_E: /* 'e' */ {
            util_.Iterator().Forward(1);
            ScanIMPLE();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_I));
    }

    inline void ScanIMPO()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_R: /* 'r' */ {
            util_.Iterator().Forward(1);
            ScanIMPOR();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_I));
    }

    inline void ScanINFE()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_R: /* 'r' */ {
            util_.Iterator().Forward(1);
            ScanINFER();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_I));
    }

    inline void ScanINST()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_A: /* 'a' */ {
            util_.Iterator().Forward(1);
            ScanINSTA();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_I));
    }

    inline void ScanINTE()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_R: /* 'r' */ {
            util_.Iterator().Forward(1);
            ScanINTER();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_I));
    }

    inline void ScanIMPLE()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_M: /* 'm' */ {
            util_.Iterator().Forward(1);
            ScanIMPLEM();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_I));
    }

    inline void ScanIMPOR()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_T: /* 't' */ {
            util_.Iterator().Forward(1);
            ScanIMPORT();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_I));
    }

    inline void ScanINFER()
    {
        switch(util_.Iterator().Peek()) {
        default: {
            if (!KeywordsUtil::IsIdentifierPart(util_.Iterator().PeekCp())) {
                util_.SetKeyword<TokenType::KEYW_INFER>("infer", TokenType::LITERAL_IDENT);
                return;
            }
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_I));
    }

    inline void ScanINSTA()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_N: /* 'n' */ {
            util_.Iterator().Forward(1);
            ScanINSTAN();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_I));
    }

    inline void ScanINTER()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_F: /* 'f' */ {
            util_.Iterator().Forward(1);
            ScanINTERF();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_I));
    }

    inline void ScanIMPLEM()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_E: /* 'e' */ {
            util_.Iterator().Forward(1);
            ScanIMPLEME();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_I));
    }

    inline void ScanIMPORT()
    {
        switch(util_.Iterator().Peek()) {
        default: {
            if (!KeywordsUtil::IsIdentifierPart(util_.Iterator().PeekCp())) {
                util_.SetKeyword<TokenType::KEYW_IMPORT>("import", TokenType::KEYW_IMPORT);
                return;
            }
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_I));
    }

    inline void ScanINSTAN()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_C: /* 'c' */ {
            util_.Iterator().Forward(1);
            ScanINSTANC();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_I));
    }

    inline void ScanINTERF()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_A: /* 'a' */ {
            util_.Iterator().Forward(1);
            ScanINTERFA();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_I));
    }

    inline void ScanIMPLEME()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_N: /* 'n' */ {
            util_.Iterator().Forward(1);
            ScanIMPLEMEN();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_I));
    }

    inline void ScanINSTANC()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_E: /* 'e' */ {
            util_.Iterator().Forward(1);
            ScanINSTANCE();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_I));
    }

    inline void ScanINTERFA()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_C: /* 'c' */ {
            util_.Iterator().Forward(1);
            ScanINTERFAC();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_I));
    }

    inline void ScanIMPLEMEN()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_T: /* 't' */ {
            util_.Iterator().Forward(1);
            ScanIMPLEMENT();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_I));
    }

    inline void ScanINSTANCE()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_O: /* 'o' */ {
            util_.Iterator().Forward(1);
            ScanINSTANCEO();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_I));
    }

    inline void ScanINTERFAC()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_E: /* 'e' */ {
            util_.Iterator().Forward(1);
            ScanINTERFACE();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_I));
    }

    inline void ScanIMPLEMENT()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_S: /* 's' */ {
            util_.Iterator().Forward(1);
            ScanIMPLEMENTS();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_I));
    }

    inline void ScanINSTANCEO()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_F: /* 'f' */ {
            util_.Iterator().Forward(1);
            ScanINSTANCEOF();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_I));
    }

    inline void ScanINTERFACE()
    {
        switch(util_.Iterator().Peek()) {
        default: {
            if (!KeywordsUtil::IsIdentifierPart(util_.Iterator().PeekCp())) {
                util_.SetKeyword<TokenType::KEYW_INTERFACE>("interface", TokenType::LITERAL_IDENT);
                return;
            }
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_I));
    }

    inline void ScanIMPLEMENTS()
    {
        switch(util_.Iterator().Peek()) {
        default: {
            if (!KeywordsUtil::IsIdentifierPart(util_.Iterator().PeekCp())) {
                util_.SetKeyword<TokenType::KEYW_IMPLEMENTS>("implements", TokenType::KEYW_IMPLEMENTS);
                return;
            }
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_I));
    }

    inline void ScanINSTANCEOF()
    {
        switch(util_.Iterator().Peek()) {
        default: {
            if (!KeywordsUtil::IsIdentifierPart(util_.Iterator().PeekCp())) {
                util_.SetKeyword<TokenType::KEYW_INSTANCEOF>("instanceof", TokenType::KEYW_INSTANCEOF);
                return;
            }
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_I));
    }

    inline void ScanK()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_E: /* 'e' */ {
            util_.Iterator().Forward(1);
            ScanKE();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_K));
    }

    inline void ScanKE()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_Y: /* 'y' */ {
            util_.Iterator().Forward(1);
            ScanKEY();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_K));
    }

    inline void ScanKEY()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_O: /* 'o' */ {
            util_.Iterator().Forward(1);
            ScanKEYO();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_K));
    }

    inline void ScanKEYO()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_F: /* 'f' */ {
            util_.Iterator().Forward(1);
            ScanKEYOF();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_K));
    }

    inline void ScanKEYOF()
    {
        switch(util_.Iterator().Peek()) {
        default: {
            if (!KeywordsUtil::IsIdentifierPart(util_.Iterator().PeekCp())) {
                util_.SetKeyword<TokenType::KEYW_KEYOF>("keyof", TokenType::LITERAL_IDENT);
                return;
            }
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_K));
    }

    inline void ScanL()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_E: /* 'e' */ {
            util_.Iterator().Forward(1);
            ScanLE();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_L));
    }

    inline void ScanLE()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_T: /* 't' */ {
            util_.Iterator().Forward(1);
            ScanLET();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_L));
    }

    inline void ScanLET()
    {
        switch(util_.Iterator().Peek()) {
        default: {
            if (!KeywordsUtil::IsIdentifierPart(util_.Iterator().PeekCp())) {
                util_.SetKeyword<TokenType::KEYW_LET>("let", TokenType::KEYW_LET);
                return;
            }
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_L));
    }

    inline void ScanM()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_E: /* 'e' */ {
            util_.Iterator().Forward(1);
            ScanME();
            return;
        }
        case LEX_CHAR_LOWERCASE_O: /* 'o' */ {
            util_.Iterator().Forward(1);
            ScanMO();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_M));
    }

    inline void ScanN()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_A: /* 'a' */ {
            util_.Iterator().Forward(1);
            ScanNA();
            return;
        }
        case LEX_CHAR_LOWERCASE_E: /* 'e' */ {
            util_.Iterator().Forward(1);
            ScanNE();
            return;
        }
        case LEX_CHAR_LOWERCASE_U: /* 'u' */ {
            util_.Iterator().Forward(1);
            ScanNU();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_N));
    }

    inline void ScanME()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_T: /* 't' */ {
            util_.Iterator().Forward(1);
            ScanMET();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_M));
    }

    inline void ScanMO()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_D: /* 'd' */ {
            util_.Iterator().Forward(1);
            ScanMOD();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_M));
    }

    inline void ScanNA()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_M: /* 'm' */ {
            util_.Iterator().Forward(1);
            ScanNAM();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_N));
    }

    inline void ScanMET()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_A: /* 'a' */ {
            util_.Iterator().Forward(1);
            ScanMETA();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_M));
    }

    inline void ScanMOD()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_U: /* 'u' */ {
            util_.Iterator().Forward(1);
            ScanMODU();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_M));
    }

    inline void ScanNAM()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_E: /* 'e' */ {
            util_.Iterator().Forward(1);
            ScanNAME();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_N));
    }

    inline void ScanMETA()
    {
        switch(util_.Iterator().Peek()) {
        default: {
            if (!KeywordsUtil::IsIdentifierPart(util_.Iterator().PeekCp())) {
                util_.SetKeyword<TokenType::KEYW_META>("meta", TokenType::LITERAL_IDENT);
                return;
            }
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_M));
    }

    inline void ScanMODU()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_L: /* 'l' */ {
            util_.Iterator().Forward(1);
            ScanMODUL();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_M));
    }

    inline void ScanNAME()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_S: /* 's' */ {
            util_.Iterator().Forward(1);
            ScanNAMES();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_N));
    }

    inline void ScanMODUL()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_E: /* 'e' */ {
            util_.Iterator().Forward(1);
            ScanMODULE();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_M));
    }

    inline void ScanNAMES()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_P: /* 'p' */ {
            util_.Iterator().Forward(1);
            ScanNAMESP();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_N));
    }

    inline void ScanMODULE()
    {
        switch(util_.Iterator().Peek()) {
        default: {
            if (!KeywordsUtil::IsIdentifierPart(util_.Iterator().PeekCp())) {
                util_.SetKeyword<TokenType::KEYW_MODULE>("module", TokenType::LITERAL_IDENT);
                return;
            }
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_M));
    }

    inline void ScanNAMESP()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_A: /* 'a' */ {
            util_.Iterator().Forward(1);
            ScanNAMESPA();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_N));
    }

    inline void ScanNAMESPA()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_C: /* 'c' */ {
            util_.Iterator().Forward(1);
            ScanNAMESPAC();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_N));
    }

    inline void ScanNAMESPAC()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_E: /* 'e' */ {
            util_.Iterator().Forward(1);
            ScanNAMESPACE();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_N));
    }

    inline void ScanNAMESPACE()
    {
        switch(util_.Iterator().Peek()) {
        default: {
            if (!KeywordsUtil::IsIdentifierPart(util_.Iterator().PeekCp())) {
                util_.SetKeyword<TokenType::KEYW_NAMESPACE>("namespace", TokenType::LITERAL_IDENT);
                return;
            }
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_N));
    }

    inline void ScanNE()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_V: /* 'v' */ {
            util_.Iterator().Forward(1);
            ScanNEV();
            return;
        }
        case LEX_CHAR_LOWERCASE_W: /* 'w' */ {
            util_.Iterator().Forward(1);
            ScanNEW();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_N));
    }

    inline void ScanNU()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_L: /* 'l' */ {
            util_.Iterator().Forward(1);
            ScanNUL();
            return;
        }
        case LEX_CHAR_LOWERCASE_M: /* 'm' */ {
            util_.Iterator().Forward(1);
            ScanNUM();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_N));
    }

    inline void ScanNEV()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_E: /* 'e' */ {
            util_.Iterator().Forward(1);
            ScanNEVE();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_N));
    }

    inline void ScanNEW()
    {
        switch(util_.Iterator().Peek()) {
        default: {
            if (!KeywordsUtil::IsIdentifierPart(util_.Iterator().PeekCp())) {
                util_.SetKeyword<TokenType::KEYW_NEW>("new", TokenType::KEYW_NEW);
                return;
            }
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_N));
    }

    inline void ScanNUL()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_L: /* 'l' */ {
            util_.Iterator().Forward(1);
            ScanNULL();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_N));
    }

    inline void ScanNUM()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_B: /* 'b' */ {
            util_.Iterator().Forward(1);
            ScanNUMB();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_N));
    }

    inline void ScanNEVE()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_R: /* 'r' */ {
            util_.Iterator().Forward(1);
            ScanNEVER();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_N));
    }

    inline void ScanNULL()
    {
        switch(util_.Iterator().Peek()) {
        default: {
            if (!KeywordsUtil::IsIdentifierPart(util_.Iterator().PeekCp())) {
                util_.SetKeyword<TokenType::LITERAL_NULL>("null", TokenType::LITERAL_NULL);
                return;
            }
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_N));
    }

    inline void ScanNUMB()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_E: /* 'e' */ {
            util_.Iterator().Forward(1);
            ScanNUMBE();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_N));
    }

    inline void ScanNEVER()
    {
        switch(util_.Iterator().Peek()) {
        default: {
            if (!KeywordsUtil::IsIdentifierPart(util_.Iterator().PeekCp())) {
                util_.SetKeyword<TokenType::KEYW_NEVER>("never", TokenType::LITERAL_IDENT);
                return;
            }
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_N));
    }

    inline void ScanNUMBE()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_R: /* 'r' */ {
            util_.Iterator().Forward(1);
            ScanNUMBER();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_N));
    }

    inline void ScanNUMBER()
    {
        switch(util_.Iterator().Peek()) {
        default: {
            if (!KeywordsUtil::IsIdentifierPart(util_.Iterator().PeekCp())) {
                util_.SetKeyword<TokenType::KEYW_NUMBER>("number", TokenType::LITERAL_IDENT);
                return;
            }
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_N));
    }

    inline void ScanO()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_B: /* 'b' */ {
            util_.Iterator().Forward(1);
            ScanOB();
            return;
        }
        case LEX_CHAR_LOWERCASE_F: /* 'f' */ {
            util_.Iterator().Forward(1);
            ScanOF();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_O));
    }

    inline void ScanOB()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_J: /* 'j' */ {
            util_.Iterator().Forward(1);
            ScanOBJ();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_O));
    }

    inline void ScanOF()
    {
        switch(util_.Iterator().Peek()) {
        default: {
            if (!KeywordsUtil::IsIdentifierPart(util_.Iterator().PeekCp())) {
                util_.SetKeyword<TokenType::KEYW_OF>("of", TokenType::LITERAL_IDENT);
                return;
            }
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_O));
    }

    inline void ScanOBJ()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_E: /* 'e' */ {
            util_.Iterator().Forward(1);
            ScanOBJE();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_O));
    }

    inline void ScanOBJE()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_C: /* 'c' */ {
            util_.Iterator().Forward(1);
            ScanOBJEC();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_O));
    }

    inline void ScanOBJEC()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_T: /* 't' */ {
            util_.Iterator().Forward(1);
            ScanOBJECT();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_O));
    }

    inline void ScanOBJECT()
    {
        switch(util_.Iterator().Peek()) {
        default: {
            if (!KeywordsUtil::IsIdentifierPart(util_.Iterator().PeekCp())) {
                util_.SetKeyword<TokenType::KEYW_OBJECT>("object", TokenType::LITERAL_IDENT);
                return;
            }
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_O));
    }

    inline void ScanP()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_A: /* 'a' */ {
            util_.Iterator().Forward(1);
            ScanPA();
            return;
        }
        case LEX_CHAR_LOWERCASE_R: /* 'r' */ {
            util_.Iterator().Forward(1);
            ScanPR();
            return;
        }
        case LEX_CHAR_LOWERCASE_U: /* 'u' */ {
            util_.Iterator().Forward(1);
            ScanPU();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_P));
    }

    inline void ScanPA()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_C: /* 'c' */ {
            util_.Iterator().Forward(1);
            ScanPAC();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_P));
    }

    inline void ScanPR()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_I: /* 'i' */ {
            util_.Iterator().Forward(1);
            ScanPRI();
            return;
        }
        case LEX_CHAR_LOWERCASE_O: /* 'o' */ {
            util_.Iterator().Forward(1);
            ScanPRO();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_P));
    }

    inline void ScanPU()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_B: /* 'b' */ {
            util_.Iterator().Forward(1);
            ScanPUB();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_P));
    }

    inline void ScanPAC()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_K: /* 'k' */ {
            util_.Iterator().Forward(1);
            ScanPACK();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_P));
    }

    inline void ScanPRI()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_V: /* 'v' */ {
            util_.Iterator().Forward(1);
            ScanPRIV();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_P));
    }

    inline void ScanPRO()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_T: /* 't' */ {
            util_.Iterator().Forward(1);
            ScanPROT();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_P));
    }

    inline void ScanPUB()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_L: /* 'l' */ {
            util_.Iterator().Forward(1);
            ScanPUBL();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_P));
    }

    inline void ScanPACK()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_A: /* 'a' */ {
            util_.Iterator().Forward(1);
            ScanPACKA();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_P));
    }

    inline void ScanPRIV()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_A: /* 'a' */ {
            util_.Iterator().Forward(1);
            ScanPRIVA();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_P));
    }

    inline void ScanPROT()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_E: /* 'e' */ {
            util_.Iterator().Forward(1);
            ScanPROTE();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_P));
    }

    inline void ScanPUBL()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_I: /* 'i' */ {
            util_.Iterator().Forward(1);
            ScanPUBLI();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_P));
    }

    inline void ScanPACKA()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_G: /* 'g' */ {
            util_.Iterator().Forward(1);
            ScanPACKAG();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_P));
    }

    inline void ScanPRIVA()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_T: /* 't' */ {
            util_.Iterator().Forward(1);
            ScanPRIVAT();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_P));
    }

    inline void ScanPROTE()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_C: /* 'c' */ {
            util_.Iterator().Forward(1);
            ScanPROTEC();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_P));
    }

    inline void ScanPUBLI()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_C: /* 'c' */ {
            util_.Iterator().Forward(1);
            ScanPUBLIC();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_P));
    }

    inline void ScanPACKAG()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_E: /* 'e' */ {
            util_.Iterator().Forward(1);
            ScanPACKAGE();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_P));
    }

    inline void ScanPRIVAT()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_E: /* 'e' */ {
            util_.Iterator().Forward(1);
            ScanPRIVATE();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_P));
    }

    inline void ScanPROTEC()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_T: /* 't' */ {
            util_.Iterator().Forward(1);
            ScanPROTECT();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_P));
    }

    inline void ScanPUBLIC()
    {
        switch(util_.Iterator().Peek()) {
        default: {
            if (!KeywordsUtil::IsIdentifierPart(util_.Iterator().PeekCp())) {
                util_.SetKeyword<TokenType::KEYW_PUBLIC>("public", TokenType::KEYW_PUBLIC);
                return;
            }
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_P));
    }

    inline void ScanPACKAGE()
    {
        switch(util_.Iterator().Peek()) {
        default: {
            if (!KeywordsUtil::IsIdentifierPart(util_.Iterator().PeekCp())) {
                util_.SetKeyword<TokenType::KEYW_PACKAGE>("package", TokenType::KEYW_PACKAGE);
                return;
            }
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_P));
    }

    inline void ScanPRIVATE()
    {
        switch(util_.Iterator().Peek()) {
        default: {
            if (!KeywordsUtil::IsIdentifierPart(util_.Iterator().PeekCp())) {
                util_.SetKeyword<TokenType::KEYW_PRIVATE>("private", TokenType::KEYW_PRIVATE);
                return;
            }
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_P));
    }

    inline void ScanPROTECT()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_E: /* 'e' */ {
            util_.Iterator().Forward(1);
            ScanPROTECTE();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_P));
    }

    inline void ScanPROTECTE()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_D: /* 'd' */ {
            util_.Iterator().Forward(1);
            ScanPROTECTED();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_P));
    }

    inline void ScanPROTECTED()
    {
        switch(util_.Iterator().Peek()) {
        default: {
            if (!KeywordsUtil::IsIdentifierPart(util_.Iterator().PeekCp())) {
                util_.SetKeyword<TokenType::KEYW_PROTECTED>("protected", TokenType::KEYW_PROTECTED);
                return;
            }
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_P));
    }

    inline void ScanR()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_E: /* 'e' */ {
            util_.Iterator().Forward(1);
            ScanRE();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_R));
    }

    inline void ScanRE()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_A: /* 'a' */ {
            util_.Iterator().Forward(1);
            ScanREA();
            return;
        }
        case LEX_CHAR_LOWERCASE_T: /* 't' */ {
            util_.Iterator().Forward(1);
            ScanRET();
            return;
        }
        case LEX_CHAR_LOWERCASE_Q: /* 'q' */ {
            util_.Iterator().Forward(1);
            ScanREQ();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_R));
    }

    inline void ScanREA()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_D: /* 'd' */ {
            util_.Iterator().Forward(1);
            ScanREAD();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_R));
    }

    inline void ScanRET()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_U: /* 'u' */ {
            util_.Iterator().Forward(1);
            ScanRETU();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_R));
    }

    inline void ScanREQ()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_U: /* 'u' */ {
            util_.Iterator().Forward(1);
            ScanREQU();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_R));
    }

    inline void ScanREAD()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_O: /* 'o' */ {
            util_.Iterator().Forward(1);
            ScanREADO();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_R));
    }

    inline void ScanRETU()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_R: /* 'r' */ {
            util_.Iterator().Forward(1);
            ScanRETUR();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_R));
    }

    inline void ScanREQU()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_I: /* 'i' */ {
            util_.Iterator().Forward(1);
            ScanREQUI();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_R));
    }

    inline void ScanREADO()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_N: /* 'n' */ {
            util_.Iterator().Forward(1);
            ScanREADON();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_R));
    }

    inline void ScanRETUR()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_N: /* 'n' */ {
            util_.Iterator().Forward(1);
            ScanRETURN();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_R));
    }

    inline void ScanREQUI()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_R: /* 'r' */ {
            util_.Iterator().Forward(1);
            ScanREQUIR();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_R));
    }

    inline void ScanREADON()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_L: /* 'l' */ {
            util_.Iterator().Forward(1);
            ScanREADONL();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_R));
    }

    inline void ScanRETURN()
    {
        switch(util_.Iterator().Peek()) {
        default: {
            if (!KeywordsUtil::IsIdentifierPart(util_.Iterator().PeekCp())) {
                util_.SetKeyword<TokenType::KEYW_RETURN>("return", TokenType::KEYW_RETURN);
                return;
            }
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_R));
    }

    inline void ScanREQUIR()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_E: /* 'e' */ {
            util_.Iterator().Forward(1);
            ScanREQUIRE();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_R));
    }

    inline void ScanREADONL()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_Y: /* 'y' */ {
            util_.Iterator().Forward(1);
            ScanREADONLY();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_R));
    }

    inline void ScanREQUIRE()
    {
        switch(util_.Iterator().Peek()) {
        default: {
            if (!KeywordsUtil::IsIdentifierPart(util_.Iterator().PeekCp())) {
                util_.SetKeyword<TokenType::KEYW_REQUIRE>("require", TokenType::LITERAL_IDENT);
                return;
            }
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_R));
    }

    inline void ScanREADONLY()
    {
        switch(util_.Iterator().Peek()) {
        default: {
            if (!KeywordsUtil::IsIdentifierPart(util_.Iterator().PeekCp())) {
                util_.SetKeyword<TokenType::KEYW_READONLY>("readonly", TokenType::LITERAL_IDENT);
                return;
            }
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_R));
    }

    inline void ScanS()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_E: /* 'e' */ {
            util_.Iterator().Forward(1);
            ScanSE();
            return;
        }
        case LEX_CHAR_LOWERCASE_T: /* 't' */ {
            util_.Iterator().Forward(1);
            ScanST();
            return;
        }
        case LEX_CHAR_LOWERCASE_U: /* 'u' */ {
            util_.Iterator().Forward(1);
            ScanSU();
            return;
        }
        case LEX_CHAR_LOWERCASE_W: /* 'w' */ {
            util_.Iterator().Forward(1);
            ScanSW();
            return;
        }
        case LEX_CHAR_LOWERCASE_Y: /* 'y' */ {
            util_.Iterator().Forward(1);
            ScanSY();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_S));
    }

    inline void ScanSE()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_T: /* 't' */ {
            util_.Iterator().Forward(1);
            ScanSET();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_S));
    }

    inline void ScanST()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_A: /* 'a' */ {
            util_.Iterator().Forward(1);
            ScanSTA();
            return;
        }
        case LEX_CHAR_LOWERCASE_R: /* 'r' */ {
            util_.Iterator().Forward(1);
            ScanSTR();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_S));
    }

    inline void ScanSU()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_P: /* 'p' */ {
            util_.Iterator().Forward(1);
            ScanSUP();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_S));
    }

    inline void ScanSW()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_I: /* 'i' */ {
            util_.Iterator().Forward(1);
            ScanSWI();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_S));
    }

    inline void ScanSY()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_M: /* 'm' */ {
            util_.Iterator().Forward(1);
            ScanSYM();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_S));
    }

    inline void ScanSET()
    {
        switch(util_.Iterator().Peek()) {
        default: {
            if (!KeywordsUtil::IsIdentifierPart(util_.Iterator().PeekCp())) {
                util_.SetKeyword<TokenType::KEYW_SET>("set", TokenType::LITERAL_IDENT);
                return;
            }
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_S));
    }

    inline void ScanSTA()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_T: /* 't' */ {
            util_.Iterator().Forward(1);
            ScanSTAT();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_S));
    }

    inline void ScanSTR()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_I: /* 'i' */ {
            util_.Iterator().Forward(1);
            ScanSTRI();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_S));
    }

    inline void ScanSUP()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_E: /* 'e' */ {
            util_.Iterator().Forward(1);
            ScanSUPE();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_S));
    }

    inline void ScanSWI()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_T: /* 't' */ {
            util_.Iterator().Forward(1);
            ScanSWIT();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_S));
    }

    inline void ScanSYM()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_B: /* 'b' */ {
            util_.Iterator().Forward(1);
            ScanSYMB();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_S));
    }

    inline void ScanSTAT()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_I: /* 'i' */ {
            util_.Iterator().Forward(1);
            ScanSTATI();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_S));
    }

    inline void ScanSTRI()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_N: /* 'n' */ {
            util_.Iterator().Forward(1);
            ScanSTRIN();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_S));
    }

    inline void ScanSUPE()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_R: /* 'r' */ {
            util_.Iterator().Forward(1);
            ScanSUPER();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_S));
    }

    inline void ScanSWIT()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_C: /* 'c' */ {
            util_.Iterator().Forward(1);
            ScanSWITC();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_S));
    }

    inline void ScanSYMB()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_O: /* 'o' */ {
            util_.Iterator().Forward(1);
            ScanSYMBO();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_S));
    }

    inline void ScanSTATI()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_C: /* 'c' */ {
            util_.Iterator().Forward(1);
            ScanSTATIC();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_S));
    }

    inline void ScanSTRIN()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_G: /* 'g' */ {
            util_.Iterator().Forward(1);
            ScanSTRING();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_S));
    }

    inline void ScanSUPER()
    {
        switch(util_.Iterator().Peek()) {
        default: {
            if (!KeywordsUtil::IsIdentifierPart(util_.Iterator().PeekCp())) {
                util_.SetKeyword<TokenType::KEYW_SUPER>("super", TokenType::KEYW_SUPER);
                return;
            }
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_S));
    }

    inline void ScanSWITC()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_H: /* 'h' */ {
            util_.Iterator().Forward(1);
            ScanSWITCH();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_S));
    }

    inline void ScanSYMBO()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_L: /* 'l' */ {
            util_.Iterator().Forward(1);
            ScanSYMBOL();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_S));
    }

    inline void ScanSTATIC()
    {
        switch(util_.Iterator().Peek()) {
        default: {
            if (!KeywordsUtil::IsIdentifierPart(util_.Iterator().PeekCp())) {
                util_.SetKeyword<TokenType::KEYW_STATIC>("static", TokenType::LITERAL_IDENT);
                return;
            }
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_S));
    }

    inline void ScanSTRING()
    {
        switch(util_.Iterator().Peek()) {
        default: {
            if (!KeywordsUtil::IsIdentifierPart(util_.Iterator().PeekCp())) {
                util_.SetKeyword<TokenType::KEYW_STRING>("string", TokenType::LITERAL_IDENT);
                return;
            }
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_S));
    }

    inline void ScanSWITCH()
    {
        switch(util_.Iterator().Peek()) {
        default: {
            if (!KeywordsUtil::IsIdentifierPart(util_.Iterator().PeekCp())) {
                util_.SetKeyword<TokenType::KEYW_SWITCH>("switch", TokenType::KEYW_SWITCH);
                return;
            }
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_S));
    }

    inline void ScanSYMBOL()
    {
        switch(util_.Iterator().Peek()) {
        default: {
            if (!KeywordsUtil::IsIdentifierPart(util_.Iterator().PeekCp())) {
                util_.SetKeyword<TokenType::KEYW_SYMBOL>("symbol", TokenType::LITERAL_IDENT);
                return;
            }
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_S));
    }

    inline void ScanT()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_H: /* 'h' */ {
            util_.Iterator().Forward(1);
            ScanTH();
            return;
        }
        case LEX_CHAR_LOWERCASE_R: /* 'r' */ {
            util_.Iterator().Forward(1);
            ScanTR();
            return;
        }
        case LEX_CHAR_LOWERCASE_Y: /* 'y' */ {
            util_.Iterator().Forward(1);
            ScanTY();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_T));
    }

    inline void ScanTH()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_I: /* 'i' */ {
            util_.Iterator().Forward(1);
            ScanTHI();
            return;
        }
        case LEX_CHAR_LOWERCASE_R: /* 'r' */ {
            util_.Iterator().Forward(1);
            ScanTHR();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_T));
    }

    inline void ScanTR()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_U: /* 'u' */ {
            util_.Iterator().Forward(1);
            ScanTRU();
            return;
        }
        case LEX_CHAR_LOWERCASE_Y: /* 'y' */ {
            util_.Iterator().Forward(1);
            ScanTRY();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_T));
    }

    inline void ScanTY()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_P: /* 'p' */ {
            util_.Iterator().Forward(1);
            ScanTYP();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_T));
    }

    inline void ScanTHI()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_S: /* 's' */ {
            util_.Iterator().Forward(1);
            ScanTHIS();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_T));
    }

    inline void ScanTHR()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_O: /* 'o' */ {
            util_.Iterator().Forward(1);
            ScanTHRO();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_T));
    }

    inline void ScanTRU()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_E: /* 'e' */ {
            util_.Iterator().Forward(1);
            ScanTRUE();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_T));
    }

    inline void ScanTRY()
    {
        switch(util_.Iterator().Peek()) {
        default: {
            if (!KeywordsUtil::IsIdentifierPart(util_.Iterator().PeekCp())) {
                util_.SetKeyword<TokenType::KEYW_TRY>("try", TokenType::KEYW_TRY);
                return;
            }
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_T));
    }

    inline void ScanTYP()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_E: /* 'e' */ {
            util_.Iterator().Forward(1);
            ScanTYPE();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_T));
    }

    inline void ScanTHIS()
    {
        switch(util_.Iterator().Peek()) {
        default: {
            if (!KeywordsUtil::IsIdentifierPart(util_.Iterator().PeekCp())) {
                util_.SetKeyword<TokenType::KEYW_THIS>("this", TokenType::KEYW_THIS);
                return;
            }
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_T));
    }

    inline void ScanTHRO()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_W: /* 'w' */ {
            util_.Iterator().Forward(1);
            ScanTHROW();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_T));
    }

    inline void ScanTRUE()
    {
        switch(util_.Iterator().Peek()) {
        default: {
            if (!KeywordsUtil::IsIdentifierPart(util_.Iterator().PeekCp())) {
                util_.SetKeyword<TokenType::LITERAL_TRUE>("true", TokenType::LITERAL_TRUE);
                return;
            }
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_T));
    }

    inline void ScanTYPE()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_O: /* 'o' */ {
            util_.Iterator().Forward(1);
            ScanTYPEO();
            return;
        }
        default: {
            if (!KeywordsUtil::IsIdentifierPart(util_.Iterator().PeekCp())) {
                util_.SetKeyword<TokenType::KEYW_TYPE>("type", TokenType::LITERAL_IDENT);
                return;
            }
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_T));
    }

    inline void ScanTHROW()
    {
        switch(util_.Iterator().Peek()) {
        default: {
            if (!KeywordsUtil::IsIdentifierPart(util_.Iterator().PeekCp())) {
                util_.SetKeyword<TokenType::KEYW_THROW>("throw", TokenType::KEYW_THROW);
                return;
            }
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_T));
    }

    inline void ScanTYPEO()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_F: /* 'f' */ {
            util_.Iterator().Forward(1);
            ScanTYPEOF();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_T));
    }

    inline void ScanTYPEOF()
    {
        switch(util_.Iterator().Peek()) {
        default: {
            if (!KeywordsUtil::IsIdentifierPart(util_.Iterator().PeekCp())) {
                util_.SetKeyword<TokenType::KEYW_TYPEOF>("typeof", TokenType::KEYW_TYPEOF);
                return;
            }
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_T));
    }

    inline void ScanU()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_N: /* 'n' */ {
            util_.Iterator().Forward(1);
            ScanUN();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_U));
    }

    inline void ScanUN()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_D: /* 'd' */ {
            util_.Iterator().Forward(1);
            ScanUND();
            return;
        }
        case LEX_CHAR_LOWERCASE_I: /* 'i' */ {
            util_.Iterator().Forward(1);
            ScanUNI();
            return;
        }
        case LEX_CHAR_LOWERCASE_K: /* 'k' */ {
            util_.Iterator().Forward(1);
            ScanUNK();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_U));
    }

    inline void ScanUND()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_E: /* 'e' */ {
            util_.Iterator().Forward(1);
            ScanUNDE();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_U));
    }

    inline void ScanUNI()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_Q: /* 'q' */ {
            util_.Iterator().Forward(1);
            ScanUNIQ();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_U));
    }

    inline void ScanUNK()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_N: /* 'n' */ {
            util_.Iterator().Forward(1);
            ScanUNKN();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_U));
    }

    inline void ScanUNDE()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_F: /* 'f' */ {
            util_.Iterator().Forward(1);
            ScanUNDEF();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_U));
    }

    inline void ScanUNIQ()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_U: /* 'u' */ {
            util_.Iterator().Forward(1);
            ScanUNIQU();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_U));
    }

    inline void ScanUNKN()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_O: /* 'o' */ {
            util_.Iterator().Forward(1);
            ScanUNKNO();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_U));
    }

    inline void ScanUNDEF()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_I: /* 'i' */ {
            util_.Iterator().Forward(1);
            ScanUNDEFI();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_U));
    }

    inline void ScanUNIQU()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_E: /* 'e' */ {
            util_.Iterator().Forward(1);
            ScanUNIQUE();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_U));
    }

    inline void ScanUNKNO()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_W: /* 'w' */ {
            util_.Iterator().Forward(1);
            ScanUNKNOW();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_U));
    }

    inline void ScanUNDEFI()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_N: /* 'n' */ {
            util_.Iterator().Forward(1);
            ScanUNDEFIN();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_U));
    }

    inline void ScanUNIQUE()
    {
        switch(util_.Iterator().Peek()) {
        default: {
            if (!KeywordsUtil::IsIdentifierPart(util_.Iterator().PeekCp())) {
                util_.SetKeyword<TokenType::KEYW_UNIQUE>("unique", TokenType::LITERAL_IDENT);
                return;
            }
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_U));
    }

    inline void ScanUNKNOW()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_N: /* 'n' */ {
            util_.Iterator().Forward(1);
            ScanUNKNOWN();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_U));
    }

    inline void ScanUNDEFIN()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_E: /* 'e' */ {
            util_.Iterator().Forward(1);
            ScanUNDEFINE();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_U));
    }

    inline void ScanUNKNOWN()
    {
        switch(util_.Iterator().Peek()) {
        default: {
            if (!KeywordsUtil::IsIdentifierPart(util_.Iterator().PeekCp())) {
                util_.SetKeyword<TokenType::KEYW_UNKNOWN>("unknown", TokenType::LITERAL_IDENT);
                return;
            }
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_U));
    }

    inline void ScanUNDEFINE()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_D: /* 'd' */ {
            util_.Iterator().Forward(1);
            ScanUNDEFINED();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_U));
    }

    inline void ScanUNDEFINED()
    {
        switch(util_.Iterator().Peek()) {
        default: {
            if (!KeywordsUtil::IsIdentifierPart(util_.Iterator().PeekCp())) {
                util_.SetKeyword<TokenType::KEYW_UNDEFINED>("undefined", TokenType::LITERAL_IDENT);
                return;
            }
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_U));
    }

    inline void ScanV()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_A: /* 'a' */ {
            util_.Iterator().Forward(1);
            ScanVA();
            return;
        }
        case LEX_CHAR_LOWERCASE_O: /* 'o' */ {
            util_.Iterator().Forward(1);
            ScanVO();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_V));
    }

    inline void ScanVA()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_R: /* 'r' */ {
            util_.Iterator().Forward(1);
            ScanVAR();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_V));
    }

    inline void ScanVO()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_I: /* 'i' */ {
            util_.Iterator().Forward(1);
            ScanVOI();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_V));
    }

    inline void ScanVAR()
    {
        switch(util_.Iterator().Peek()) {
        default: {
            if (!KeywordsUtil::IsIdentifierPart(util_.Iterator().PeekCp())) {
                util_.SetKeyword<TokenType::KEYW_VAR>("var", TokenType::KEYW_VAR);
                return;
            }
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_V));
    }

    inline void ScanVOI()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_D: /* 'd' */ {
            util_.Iterator().Forward(1);
            ScanVOID();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_V));
    }

    inline void ScanVOID()
    {
        switch(util_.Iterator().Peek()) {
        default: {
            if (!KeywordsUtil::IsIdentifierPart(util_.Iterator().PeekCp())) {
                util_.SetKeyword<TokenType::KEYW_VOID>("void", TokenType::KEYW_VOID);
                return;
            }
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_V));
    }

    inline void ScanW()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_H: /* 'h' */ {
            util_.Iterator().Forward(1);
            ScanWH();
            return;
        }
        case LEX_CHAR_LOWERCASE_I: /* 'i' */ {
            util_.Iterator().Forward(1);
            ScanWI();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_W));
    }

    inline void ScanWH()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_I: /* 'i' */ {
            util_.Iterator().Forward(1);
            ScanWHI();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_W));
    }

    inline void ScanWI()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_T: /* 't' */ {
            util_.Iterator().Forward(1);
            ScanWIT();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_W));
    }

    inline void ScanWHI()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_L: /* 'l' */ {
            util_.Iterator().Forward(1);
            ScanWHIL();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_W));
    }

    inline void ScanWIT()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_H: /* 'h' */ {
            util_.Iterator().Forward(1);
            ScanWITH();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_W));
    }

    inline void ScanWHIL()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_E: /* 'e' */ {
            util_.Iterator().Forward(1);
            ScanWHILE();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_W));
    }

    inline void ScanWITH()
    {
        switch(util_.Iterator().Peek()) {
        default: {
            if (!KeywordsUtil::IsIdentifierPart(util_.Iterator().PeekCp())) {
                util_.SetKeyword<TokenType::KEYW_WITH>("with", TokenType::KEYW_WITH);
                return;
            }
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_W));
    }

    inline void ScanWHILE()
    {
        switch(util_.Iterator().Peek()) {
        default: {
            if (!KeywordsUtil::IsIdentifierPart(util_.Iterator().PeekCp())) {
                util_.SetKeyword<TokenType::KEYW_WHILE>("while", TokenType::KEYW_WHILE);
                return;
            }
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_W));
    }

    inline void ScanY()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_I: /* 'i' */ {
            util_.Iterator().Forward(1);
            ScanYI();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_Y));
    }

    inline void ScanYI()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_E: /* 'e' */ {
            util_.Iterator().Forward(1);
            ScanYIE();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_Y));
    }

    inline void ScanYIE()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_L: /* 'l' */ {
            util_.Iterator().Forward(1);
            ScanYIEL();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_Y));
    }

    inline void ScanYIEL()
    {
        switch(util_.Iterator().Peek()) {
        case LEX_CHAR_LOWERCASE_D: /* 'd' */ {
            util_.Iterator().Forward(1);
            ScanYIELD();
            return;
        }
        default: {
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_Y));
    }

    inline void ScanYIELD()
    {
        switch(util_.Iterator().Peek()) {
        default: {
            if (!KeywordsUtil::IsIdentifierPart(util_.Iterator().PeekCp())) {
                util_.SetKeyword<TokenType::KEYW_YIELD>("yield", TokenType::KEYW_YIELD);
                return;
            }
            break;
        }
        }
        util_.ScanIdContinueMaybeKeyword(Span<const KeywordString>(KeywordsMap::KEYWORDS_Y));
    }


private:
    KeywordsUtil util_;
};

} // namespace panda::es2panda::lexer
