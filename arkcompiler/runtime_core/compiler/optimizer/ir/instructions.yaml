# Copyright (c) 2021-2022 Huawei Device Co., Ltd.
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

doc: |
  opcode
    Opcode of the instruction

  signature
    Describes signature of the instruction. Properties of the operands are separated by '-' symbol.
    For info about operand tokens see the 'legend' section

    Note: any check instructions might be eliminated by optimizer, thus operand checks (nc, zc, bc, ngc) qualifiers have
          not mandatory meaning.

  base
    C++ base that represent this opcode. In far future if we managed to generate also instruction classes,
    this field become redundant

  flags
    Properties of the instruction, such as: arithmetic, binop, throw, etc

  modes
    Modes which the instruction can be used in

templates:
  # Templates aim to reduce boilerplate in instruction description.
  # Templates are denoted by a '$' symbol in the first character of the string.
  verify_unary:
    - equal_common_types
    - float_src_eq_dst_size
    - integer_src_ge_dst_size
  verify_binary_int:
    - equal_common_types
    - integer_src_ge_dst_size
  verify_binary:
    - equal_common_types
    - integer_src_ge_dst_size
    - float_src_eq_dst_size

instructions:
    ##############################################################################
    # Arithmetic/comparison instructions
    #
  - opcode: Neg
    base: UnaryOperation
    signature: [d-number, number]
    flags: [acc_write, acc_read, ifcvt]
    description: Negate the value.
    verification:
      - $verify_unary

  - opcode: Abs
    base: UnaryOperation
    signature: [d-number, number]
    flags: [acc_write, ifcvt]
    description: Get absolute value.
    verification:
      - $verify_unary

  - opcode: Sqrt
    base: UnaryOperation
    signature: [d-float, float]
    flags: [acc_write, ifcvt]
    description: Get square root value.
    verification:
      - $verify_unary

  - opcode: Not
    base: UnaryOperation
    signature: [d-int-bool, int-bool]
    flags: [acc_write, acc_read, ifcvt]
    description: Bitwise NOT.
    verification:
      - $verify_binary_int

  - opcode: Add
    base: BinaryOperation
    signature: [d-number-ptr, number-ptr, number-ptr]
    flags: [commutative, acc_write, acc_read, ifcvt]
    description: Add two inputs.
    verification:
      - $verify_binary

  - opcode: Sub
    base: BinaryOperation
    signature: [d-number-ptr, number-ptr, number-ptr]
    flags: [acc_write, acc_read, ifcvt]
    description: Substitute two inputs.
    verification:
      - $verify_binary

  - opcode: Mul
    base: BinaryOperation
    signature: [d-number, number, number]
    flags: [commutative, acc_write, acc_read, ifcvt]
    description: Multiply two inputs.
    verification:
      - $verify_binary

  - opcode: Div
    base: BinaryOperation
    signature: [d-number, number, number-zc]
    flags: [acc_write, acc_read]
    description: Divide two inputs.
    verification:
      - $verify_binary

  - opcode: Mod
    base: BinaryOperation
    signature: [d-number, number, number-zc]
    flags: [acc_write, acc_read]
    description: Modulo instruction.
    verification:
      - $verify_binary_int

  - opcode: Min
    base: BinaryOperation
    signature: [d-number, number, number]
    flags: [commutative, ifcvt]
    modes: [jit_aot, irtoc]
    description: Get minimum from two inputs. If either value is NaN, then the result is NaN. Negative zero is strictly smaller than positive zero.

  - opcode: Max
    base: BinaryOperation
    signature: [d-number, number, number]
    flags: [commutative, ifcvt]
    modes: [jit_aot, irtoc]
    description: Get maximum from two inputs. If either value is NaN, then the result is NaN. Negative zero is strictly smaller than positive zero.

  - opcode: Shl
    base: BinaryOperation
    signature: [d-int, int, int]
    flags: [acc_write, acc_read, ifcvt]
    description: Shift left.
    verification:
      - $verify_binary_int

  - opcode: Shr
    base: BinaryOperation
    signature: [d-int, int, int]
    flags: [acc_write, acc_read, ifcvt]
    description: Shift right.
    verification:
      - $verify_binary_int

  - opcode: AShr
    base: BinaryOperation
    signature: [d-int, int, int]
    flags: [acc_write, acc_read, ifcvt]
    description: Arithmetic shift left.
    verification:
      - $verify_binary_int

  - opcode: And
    base: BinaryOperation
    signature: [d-int-bool, int-bool, int-bool]
    flags: [commutative, acc_write, acc_read, ifcvt]
    description: Bitwise AND.
    verification:
      - $verify_binary_int

  - opcode: Or
    base: BinaryOperation
    signature: [d-int-bool, int-bool, int-bool]
    flags: [commutative, acc_write, acc_read, ifcvt]
    description: Bitwise OR.
    verification:
      - $verify_binary_int

  - opcode: Xor
    base: BinaryOperation
    signature: [d-int-bool, int-bool, int-bool]
    flags: [commutative, acc_write, acc_read, ifcvt]
    description: Bitwise XOR.
    verification:
      - $verify_binary_int

  - opcode: Compare
    base: CompareInst
    signature: [d-bool, real, real]
    flags: [acc_read, acc_write, ifcvt]
    description: Compare two integer or reference values according to condition code(for reference only CC_EQ).

  - opcode: Cmp
    base: CmpInst
    signature: [d-int, number, number]
    flags: [acc_read, acc_write, ifcvt]
    description:  Compare two float or integer values.

  - opcode: CompareAnyType
    base: CompareAnyTypeInst
    signature: [d-bool, any]
    flags: [acc_read, acc_write, ifcvt]
    description:  Compare any type value and type.

  - opcode: CastAnyTypeValue
    base: CastAnyTypeValueInst
    signature: [d-real, any]
    flags: [acc_read, acc_write]
    description:  Cast any dynamic type value to compiler type value.

  - opcode: CastValueToAnyType
    base: CastValueToAnyTypeInst
    signature: [d-any, real]
    flags: [acc_read, acc_write, no_cse]
    description:  Cast compiler type value to any dynamic type value.

  - opcode: Cast
    base: CastInst
    signature: [d-real-any, real-any]
    flags: [acc_read, acc_write, ifcvt]
    description: Cast value from one type to another. Don't support casts from float32/64 to int8/16 and bool.

  - opcode: Constant
    base: ConstantInst
    signature: [d-i32-i64-f32-f64]
    flags: [no_cse, ifcvt]
    description: Constant value.
    verification:
      - start_block_instruction

  - opcode: Parameter
    base: ParameterInst
    signature: [d-real-any]
    flags: [no_cse, no_hoist]
    description: Method's parameter.
    verification:
      - start_block_instruction

  - opcode: NullPtr
    base: FixedInputsInst0
    signature: [d-ref]
    flags: [no_cse, no_hoist, ifcvt]
    description: Null pointer.
    verification:
      - start_block_instruction

    ##############################################################################
    # Object/array instructions
    #
  - opcode: NewArray
    base: NewArrayInst
    signature: [d-ref, ref, int-ngc, save_state]
    flags: [can_throw, no_dce, no_hoist, no_cse, alloc, require_state, runtime_call, mem_barrier]
    description: Create new array with non-negative size specified by first input.
    fields:
      - type_id: TypeId

  - opcode: NewObject
    base: NewObjectInst
    signature: [d-ref, ref, save_state]
    flags: [can_throw, no_dce, no_hoist, no_cse, alloc, require_state, runtime_call, mem_barrier]
    description: Create new object.
    fields:
      - type_id: TypeId

  - opcode: InitObject
    base: CallInst
    signature: [d-ref, real-dyn, save_state]
    flags: [can_throw, no_dce, no_hoist, no_cse, alloc, require_state, runtime_call, acc_write]
    description: Create new object and then call default constructor for it.
    fields:
      - type_id: TypeId

  - opcode: LoadArray
    base: LoadInst
    signature: [d-real, ref-nc, int-bc]
    flags: [load, no_hoist, no_cse, acc_read, acc_write]
    description: Load value from array.

  - opcode: LoadCompressedStringChar
    base: LoadCompressedStringCharInst
    signature: [d-u16, ref-nc, int-bc, int]
    flags: [load, no_cse, acc_read, acc_write]
    description: Load char from string while string compression is enable.

  - opcode: StoreArray
    base: StoreInst
    signature: [ref-nc, int-bc, real]
    flags: [store, no_dce, no_hoist, no_cse, acc_read]
    description: Store value in array.

  - opcode: LoadObject
    base: LoadObjectInst
    signature: [d-real, ref-nc]
    flags: [load, no_hoist, no_cse, acc_write]
    description: Load value from object's field.
    fields:
      - field_id: TypeId

  - opcode: Load
    base: LoadMemInst
    signature: [d-real, ptr-ref, int]
    flags: [native, low_level, load, no_hoist, no_cse]
    modes: [jit_aot, irtoc]
    description: Load value from memory by offset. If Load is volatile, the address must have the normal alignment(by size of loaded value)

  - opcode: LoadI
    base: LoadMemInstI
    signature: [d-real, ptr-ref]
    flags: [native, low_level, load, no_hoist, no_cse]
    modes: [irtoc]
    description: Load value from memory by immediate offset. If Load is volatile, the address must have the normal alignment(by size of loaded value)

  - opcode: Store
    base: StoreMemInst
    signature: [ptr-ref, int, real]
    flags: [native, low_level, store, no_dce, no_hoist, no_cse]
    modes: [jit_aot, irtoc]
    description: Store value in memory by offset. If Store is volatile, the address must have the normal alignment(by size of stored value)

  - opcode: StoreI
    base: StoreMemInstI
    signature: [ptr-ref, real]
    flags: [native, low_level, store, no_dce, no_hoist, no_cse]
    modes: [irtoc]
    description: Store value in memory by immediate offset. If Store is volatile, the address must have the normal alignment(by size of stored value)

  - opcode: UnresolvedLoadObject
    base: UnresolvedLoadObjectInst
    signature: [d-real, ref-nc, save_state]
    flags: [load, can_throw, no_dce, no_cse, no_hoist, barrier, require_state, runtime_call, implicit_runtime_call]
    modes: [jit_aot]
    description: Load value from object's unresolved field.
    field:
      - field_id: TypeId

  - opcode: StoreObject
    base: StoreObjectInst
    signature: [ref-nc, real]
    flags: [store, no_dce, no_hoist, no_cse, acc_read]
    description: Store value in object's field.
    fields:
      - field_id: TypeId

  - opcode: UnresolvedStoreObject
    base: UnresolvedStoreObjectInst
    signature: [ref-nc, real, save_state]
    flags: [store, can_throw, no_dce, no_cse, no_hoist, barrier, require_state, runtime_call, implicit_runtime_call]
    modes: [jit_aot]
    description: Load value from object's unresolved field.
    field:
      - field_id: TypeId

  - opcode: LoadStatic
    base: LoadStaticInst
    signature: [d-real, ref]
    flags: [load, no_hoist, no_cse, acc_write]
    description: Load static field from class.
    fields:
      - field_id: TypeId

  - opcode: UnresolvedLoadStatic
    base: UnresolvedLoadStaticInst
    signature: [d-real, save_state]
    flags: [load, can_throw, no_dce, no_hoist, no_cse, barrier, require_state, runtime_call, implicit_runtime_call]
    modes: [jit_aot]
    description: Load unresolved static field from class.
    fields:
      - field_id: TypeId

  - opcode: StoreStatic
    base: StoreStaticInst
    signature: [ref, real]
    flags: [store, no_dce, no_hoist, no_cse, acc_read]
    description: Store value into static field.
    fields:
      - field_id: TypeId

  - opcode: UnresolvedStoreStatic
    base: UnresolvedStoreStaticInst
    signature: [real, save_state]
    flags: [store, can_throw, no_dce, no_hoist, no_cse, barrier, require_state, runtime_call, implicit_runtime_call]
    modes: [jit_aot]
    description: Store value into unresolved static field.
    fields:
      - field_id: TypeId

  - opcode: LenArray
    base: LengthMethodInst
    signature: [d-int, ref-nc]
    flags: [acc_write]
    description: Get length of array.

  - opcode: LoadString
    base: LoadFromPool
    signature: [d-ref, save_state]
    flags: [load, can_throw, no_hoist, no_cse, require_state, runtime_call, acc_write]
    description: Load string from pool.

  - opcode: LoadConstArray
    base: LoadConstArrayInst
    signature: [d-ref, save_state]
    flags: [load, can_throw, no_hoist, no_dce, no_cse, require_state, barrier, runtime_call]
    description: Creates a new constant array by id and fills its contents (array elements are literals).

  - opcode: FillConstArray
    base: FillConstArrayInst
    signature: [ref, save_state]
    flags: [store, no_hoist, no_dce, no_cse, no_dst, require_state, barrier, runtime_call]
    description: Fill constant array by contents (array elements are literals).

  - opcode: LoadType
    base: LoadFromPool
    signature: [d-ref, save_state]
    flags: [load, can_throw, no_hoist, no_cse, require_state, runtime_call, acc_write]
    description: Load type from pool.

  - opcode: UnresolvedLoadType
    base: LoadFromPool
    signature: [d-ref, save_state]
    flags: [load, can_throw, no_dce, no_hoist, barrier, no_cse, require_state, runtime_call, implicit_runtime_call]
    modes: [jit_aot]
    description: Load unresolved type from pool.

  - opcode: CheckCast
    base: CheckCastInst
    signature: [ref, ref, save_state]
    flags: [can_throw, no_dce, no_hoist, no_cse, require_state, runtime_call, acc_read]
    description: >-
      If an object in the first input can't be cast to the type in the second input ClassCastException is thrown.
      'null' object reference can be cast to every type.
    fields:
      - type_id: TypeId

  - opcode: IsInstance
    base: IsInstanceInst
    signature: [d-bool, ref, ref, save_state]
    flags: [require_state, runtime_call, acc_read, acc_write]
    description: >-
      Returns 1 if an object in the first input can be cast to the type in the second input, else returns 0.
      'null' object is not an instance of any class.
    fields:
      - type_id: TypeId

  - opcode: InitClass
    base: ClassInst
    signature: [save_state]
    flags: [can_throw, no_hoist, barrier, no_dce, require_state, runtime_call]
    description: Calls initialization of the class before inlined function
    fields:
      - type_id: TypeId

  - opcode: LoadClass
    base: ClassInst
    signature: [d-ref, save_state]
    flags: [can_throw, no_hoist, barrier, no_dce, require_state, runtime_call]
    description: Loads class
    fields:
      - type_id: TypeId

  - opcode: LoadAndInitClass
    base: ClassInst
    signature: [d-ref, save_state]
    flags: [can_throw, no_dce, no_hoist, barrier, require_state, runtime_call]
    description: Calls initialization of the class before LoadStatic and StoreStatc
    fields:
      - type_id: TypeId

  - opcode: UnresolvedLoadAndInitClass
    base: ClassInst
    signature: [d-ref, save_state]
    flags: [can_throw, no_dce, no_cse, no_hoist, barrier, require_state, runtime_call, implicit_runtime_call]
    modes: [jit_aot]
    description: Calls initialization of the class that wasn't resolved during compilation before LoadStatic and StoreStatc
    fields:
      - type_id: TypeId

  - opcode: GetInstanceClass
    base: FixedInputsInst1
    signature: [d-ref, ref]
    flags: [ref_special]
    description: >-
        Get class from the input object. Each object holds reference to the class on the specific offset.
        This instruction reads this reference from the input object.

  - opcode: ClassImmediate
    base: ClassImmediateInst
    signature: [d-ref]
    flags: [ref_special, no_cse, ifcvt, no_hoist]
    description: >-
      Get class object from the immediate.

    ##############################################################################
    # Check instructions
    #
  - opcode: NullCheck
    base: NullCheckInst
    signature: [d-ref-pseudo, ref, save_state]
    flags: [can_throw, is_check, no_dce, no_hoist, no_cse, require_state]
    description: Check object is not null.

  - opcode: BoundsCheck
    base: BoundsCheckInst
    signature: [d-int-pseudo, int, int, save_state]
    flags: [can_throw, is_check, no_dce, no_cse, no_hoist, require_state, acc_read]
    description: Check that value is within specified bounds.

  - opcode: RefTypeCheck
    base: FixedInputsInst3
    signature: [d-ref-pseudo, ref, ref, save_state]
    flags: [can_throw, no_dce, is_check, no_hoist, no_cse, require_state, runtime_call]
    description: Check that the type of the stored Reference matches the type of the array.

  - opcode: ZeroCheck
    base: FixedInputsInst2
    signature: [d-int-pseudo, int, save_state]
    flags: [can_throw, is_check, no_dce, no_cse, no_hoist, require_state]
    description: Check that integer value is not zero.

  - opcode: NegativeCheck
    base: FixedInputsInst2
    signature: [d-int-pseudo, int, save_state]
    flags: [can_throw, is_check, no_dce, no_cse, no_hoist, require_state]
    description: Check that integer value is less than zero.

  - opcode: AnyTypeCheck
    base: AnyTypeCheckInst
    signature: [d-any-pseudo, any, save_state]
    flags: [can_throw, no_dce, is_check, no_hoist, require_state, runtime_call, can_deoptimize]
    description: Compare any type value and type and deoptimize if the types are different

  - opcode: Deoptimize
    base: DeoptimizeInst
    signature: [save_state]
    flags: [cf, can_throw, no_dce, no_cse, no_hoist, require_state, barrier, can_deoptimize, terminator]
    modes: [jit_aot]
    description: Unconditionally switch to interpreter.

  - opcode: DeoptimizeIf
    base: DeoptimizeIfInst
    signature: [int-bool, save_state]
    flags: [can_throw, no_dce, no_cse, no_hoist, require_state, acc_read, barrier, can_deoptimize]
    modes: [jit_aot]
    description: Jump to interpreter if value is true.

  - opcode: DeoptimizeCompare
    base: DeoptimizeCompareInst
    signature: [int-bool-ref, int-bool-ref, save_state]
    flags: [can_throw, no_dce, no_cse, no_hoist, require_state, acc_read, barrier, can_deoptimize, low_level]
    modes: [jit_aot]
    description: Compare and jump to interpreter if the result is true.

  - opcode: DeoptimizeCompareImm
    base: DeoptimizeCompareImmInst
    signature: [int-bool-ref, save_state]
    flags: [can_throw, no_dce, no_cse, no_hoist, require_state, acc_read, barrier, can_deoptimize, low_level]
    modes: [jit_aot]
    description: Compare and jump to interpreter if the result is true.

  - opcode: IsMustDeoptimize
    base: Inst
    signature: [d-bool]
    flags: [no_cse, no_hoist]
    modes: [jit_aot]
    description: Check whether current method must be deoptimized.

    ##############################################################################
    # Control flow instructions
    #
  - opcode: ReturnVoid
    base: FixedInputsInst0
    signature: []
    flags: [cf, no_dce, no_hoist, no_cse, barrier, terminator]
    description: Return from method.

  - opcode: Return
    base: FixedInputsInst1
    signature: [real-any]
    flags: [cf, no_dce, no_hoist, no_cse, barrier, acc_read, terminator]
    description: Return value from method.

  - opcode: ReturnInlined
    base: ReturnInlinedInst
    signature: [save_state]
    flags: [no_dce, no_hoist, no_cse, barrier, require_state, acc_read]
    modes: [jit_aot]
    description: Return from inlined method.

  - opcode: Throw
    base: ThrowInst
    signature: [ref, save_state]
    flags: [cf, can_throw, no_dce, no_hoist, no_cse, barrier, require_state, terminator]
    modes: [jit_aot, bytecode_opt]
    description: Throw an exception. It also might raise NullReferenceException if the exception is null.

  - opcode: IndirectJump
    base: FixedInputsInst1
    signature: [ptr]
    flags: [native, cf, no_dce, no_hoist, no_cse, barrier, low_level]
    modes: [irtoc]
    description: Jump execution to specified offset using a register.

    ##############################################################################
    # Call instructions
    #
  - opcode: CallStatic
    base: CallInst
    signature: [d-real-void, real-dyn, save_state]
    flags: [can_throw, no_dce, no_hoist, no_cse, barrier, require_state, runtime_call, call, acc_write, acc_read]
    description: Calls static method.

  - opcode: UnresolvedCallStatic
    base: CallInst
    signature: [d-real-void, real-dyn, save_state]
    flags: [can_throw, no_dce, no_hoist, no_cse, barrier, require_state, runtime_call, call, implicit_runtime_call]
    modes: [jit_aot]
    description: Calls static method that was not resolved during compilation

  - opcode: CallVirtual
    base: CallInst
    signature: [d-real-void, ref-nc, real-dyn, save_state]
    flags: [can_throw, no_dce, no_hoist, no_cse, barrier, require_state, runtime_call, call, acc_write, acc_read]
    description: Calls virtual method. First input is an object reference.

  - opcode: UnresolvedCallVirtual
    base: CallInst
    signature: [d-real-void, ref-nc, real-dyn, save_state]
    flags: [can_throw, no_dce, no_hoist, no_cse, barrier, require_state, runtime_call, call, implicit_runtime_call]
    modes: [jit_aot]
    description: Calls virtual method that was not resolved during compilation. First input is an object reference.

  - opcode: CallDynamic
    base: CallInst
    signature: [d-any-void, any-dyn, save_state]
    flags: [can_throw, no_dce, no_hoist, no_cse, barrier, require_state, runtime_call, call]
    description: Calls dynamic method.

  - opcode: CallIndirect
    base: CallIndirectInst
    signature: [d-real-void, ptr, real-dyn]
    flags: [can_throw, no_dce, no_hoist, no_cse, barrier, call, low_level]
    modes: [irtoc]
    description: Low-level call by the address given from the first input.

  - opcode: Call
    base: CallInst
    signature: [ d-real-void, real-dyn ]
    flags: [ can_throw, no_dce, no_hoist, no_cse, barrier, call, low_level ]
    description: |
      Low-level call. Target function can be specified by the different ways. Currently, it supports only string name of
      the target function, which will be resolved during linking phase of the host compiler.

  - opcode: MultiArray
    base: CallInst
    signature: [d-ref, ref, int-ngc-dyn, save_state]
    flags: [can_throw, no_dce, no_hoist, no_cse, barrier, require_state, runtime_call, mem_barrier]
    modes: [jit_aot, irtoc]
    description: Creates MultiDimensional Array(a[X][Y][Z]). First input is class. Next inputs - size of arrayes(X, Y, Z).

  - opcode: Monitor
    base: MonitorInst
    signature: [ref-nc, save_state]
    flags: [can_throw, no_dce, no_hoist, no_cse, barrier, require_state, runtime_call, acc_read]
    modes: [jit_aot, bytecode_opt]
    description: Enable or disable monitor for the object(If field "Exit" is set, the monitor is disabled)

  - opcode: Intrinsic
    base: IntrinsicInst
    signature: [d-real-void, real-dyn]
    flags: [no_dce, no_hoist, no_cse, barrier, require_state, runtime_call]
    description: Call runtime intrinsics directly.

  - opcode: Builtin
    base: IntrinsicInst
    signature: [d-real-void, real-dyn]
    flags: []
    description: Expand known intrinsics using Encoder

    ##############################################################################
    # Low-level instructions
    #
  - opcode: AddI
    base: BinaryImmOperation
    signature: [d-number-ptr, real-ptr]
    flags: [low_level, acc_write, acc_read, ifcvt]
    description: Add an immediate to a value, the value may be a pointer as well

  - opcode: SubI
    base: BinaryImmOperation
    signature: [d-number-ptr, number-ptr]
    flags: [low_level, acc_write, acc_read, ifcvt]
    description: Add immediate from value.

  - opcode: MulI
    base: BinaryImmOperation
    signature: [d-int, int]
    flags: [low_level, acc_write, acc_read, ifcvt]
    modes: [bytecode_opt]
    description: Multiply value with immediate.

  - opcode: DivI
    base: BinaryImmOperation
    signature: [d-int, int]
    flags: [low_level, acc_write, acc_read, ifcvt]
    modes: [bytecode_opt]
    description: Divide value with immediate.

  - opcode: ModI
    base: BinaryImmOperation
    signature: [d-int, int]
    flags: [low_level, acc_write, acc_read, ifcvt]
    modes: [bytecode_opt]
    description: Modulo instruction with immediate.

  - opcode: ShlI
    base: BinaryImmOperation
    signature: [d-int, int]
    flags: [low_level, acc_write, acc_read, ifcvt]
    description: Shift left.

  - opcode: ShrI
    base: BinaryImmOperation
    signature: [d-int, int]
    flags: [low_level, acc_write, acc_read, ifcvt]
    description: Shift right.

  - opcode: AShrI
    base: BinaryImmOperation
    signature: [d-int, int]
    flags: [low_level, acc_write, acc_read, ifcvt]
    description: Arithmetic shift right.

  - opcode: AndI
    base: BinaryImmOperation
    signature: [d-int-bool, int-bool]
    flags: [low_level, acc_write, acc_read, ifcvt]
    description: Bitwise AND.

  - opcode: OrI
    base: BinaryImmOperation
    signature: [d-int-bool, int-bool]
    flags: [low_level, acc_write, acc_read, ifcvt]
    description: Bitwise OR.

  - opcode: XorI
    base: BinaryImmOperation
    signature: [d-int-bool, int-bool]
    flags: [low_level, acc_write, acc_read, ifcvt]
    description: Bitwise XOR.

  - opcode: MAdd
    base: FixedInputsInst3
    signature: [d-number, number, number, number]
    flags: [low_level, ifcvt]
    modes: [jit_aot, irtoc]
    description: Multiply-accumulate.

  - opcode: MSub
    base: FixedInputsInst3
    signature: [d-number, number, number, number]
    flags: [low_level, ifcvt]
    modes: [jit_aot, irtoc]
    description: Multiply-subtract.

  - opcode: MNeg
    base: BinaryOperation
    signature: [d-number, number, number]
    flags: [low_level, ifcvt]
    modes: [jit_aot, irtoc]
    description: Negated multiply.

  - opcode: OrNot
    base: BinaryOperation
    signature: [d-int-bool, int-bool, int-bool]
    flags: [low_level, ifcvt]
    modes: [jit_aot, irtoc]
    description: Bitwise OR of first operand and result of bitwise NOT of seconds operand.

  - opcode: AndNot
    base: BinaryOperation
    signature: [d-int, int-bool, int-bool]
    flags: [low_level, ifcvt]
    modes: [jit_aot, irtoc]
    description: Bitwise AND of first operand and result of bitwise NOT of seconds operand.

  - opcode: XorNot
    base: BinaryOperation
    signature: [d-int-bool, int-bool, int-bool]
    flags: [low_level, ifcvt]
    modes: [jit_aot, irtoc]
    description: Bitwise XOR of first operand and result of bitwise NOT of seconds operand.

  - opcode: AndSR
    base: BinaryShiftedRegisterOperation
    signature: [d-int, int, int]
    flags: [low_level, ifcvt]
    modes: [jit_aot, irtoc]
    description: Bitwise AND between first operand and shifted value of second operand.

  - opcode: OrSR
    base: BinaryShiftedRegisterOperation
    signature: [d-int, int, int]
    flags: [low_level, ifcvt]
    modes: [jit_aot, irtoc]
    description: Bitwise OR between first operand and shifted value of second operand.

  - opcode: XorSR
    base: BinaryShiftedRegisterOperation
    signature: [d-int, int, int]
    flags: [low_level, ifcvt]
    modes: [jit_aot, irtoc]
    description: Bitwise XOR between first operand and shifted value of second operand.

  - opcode: AndNotSR
    base: BinaryShiftedRegisterOperation
    signature: [d-int, int, int]
    flags: [low_level, ifcvt]
    modes: [jit_aot, irtoc]
    description: Bitwise AND between first operand and NOT of shifted value of second operand.

  - opcode: OrNotSR
    base: BinaryShiftedRegisterOperation
    signature: [d-int, int, int]
    flags: [low_level, ifcvt]
    modes: [jit_aot, irtoc]
    description: Bitwise OR between first operand and NOT of shifted value of second operand.

  - opcode: XorNotSR
    base: BinaryShiftedRegisterOperation
    signature: [d-int, int, int]
    flags: [low_level, ifcvt]
    modes: [jit_aot, irtoc]
    description: Bitwise XOR between first operand and NOT of shifted value of second operand.

  - opcode: AddSR
    base: BinaryShiftedRegisterOperation
    signature: [d-int, int, int]
    flags: [low_level, ifcvt]
    modes: [jit_aot, irtoc]
    description: Add first operand with shifted value of second operand.

  - opcode: SubSR
    base: BinaryShiftedRegisterOperation
    signature: [d-int, int, int]
    flags: [low_level, ifcvt]
    modes: [jit_aot, irtoc]
    description: Subtract shifted value of second operand from first operand.

  - opcode: NegSR
    base: UnaryShiftedRegisterOperation
    signature: [d-int, int]
    flags: [low_level, ifcvt]
    modes: [jit_aot, irtoc]
    description: Shift and then negate operands value.

  - opcode: BoundsCheckI
    base: BoundsCheckInstI
    signature: [d-int-pseudo, int, save_state]
    flags: [can_throw, is_check, no_dce, no_hoist, no_cse, require_state, low_level]
    description: Check that value is within specified bounds.

  - opcode: LoadArrayI
    base: LoadInstI
    signature: [d-real, ref-nc]
    flags: [load, no_hoist, no_cse, low_level, acc_read, acc_write]
    modes: [jit_aot, irtoc]
    description: Load value from array.

  - opcode: LoadCompressedStringCharI
    base: LoadCompressedStringCharInstI
    signature: [d-u16, ref-nc, int]
    flags: [load, no_cse, low_level, acc_read, acc_write]
    description: Load char from string while string compression is enable.

  - opcode: StoreArrayI
    base: StoreInstI
    signature: [ref-nc, real]
    flags: [store, no_dce, no_hoist, no_cse, low_level, acc_read]
    modes: [jit_aot]
    description: Store value in array.

  - opcode: LoadArrayPair
    base: LoadArrayPairInst
    signature: [d-real, ref-nc, int-bc]
    flags: [load, no_hoist, no_cse, low_level, acc_write]
    modes: [jit_aot, irtoc]
    description: Load several values at a time from array.

  - opcode: LoadArrayPairI
    base: LoadArrayPairInstI
    signature: [d-real, ref-nc]
    flags: [load, no_hoist, no_cse, low_level, acc_write]
    modes: [jit_aot, irtoc]
    description: Load several values at a time from array at immediate index.

  - opcode: LoadPairPart
    base: LoadPairPartInst
    signature: [d-real-pseudo, real]
    flags: [load, low_level, acc_write, no_hoist, no_cse]
    modes: [jit_aot, irtoc]
    description: Load element from vector.

  - opcode: StoreArrayPair
    base: StoreArrayPairInst
    signature: [ref-nc, int-bc, real, real]
    flags: [store, no_dce, no_hoist, no_cse, low_level, acc_read]
    modes: [jit_aot, irtoc]
    description: Store several values at a time to array.

  - opcode: StoreArrayPairI
    base: StoreArrayPairInstI
    signature: [ref-nc, real, real]
    flags: [store, no_dce, no_hoist, no_cse, low_level, acc_read]
    modes: [jit_aot, irtoc]
    description: Store several values at a time to array at immediate index.

  - opcode: ReturnI
    base: ReturnInstI
    signature: []
    flags: [cf, no_dce, no_hoist, no_cse, barrier, low_level, acc_read, terminator]
    modes: [jit_aot, irtoc]
    description: Return value from method.

    ##############################################################################
    # Special pseudo instructions
    #
  - opcode: Phi
    base: PhiInst
    signature: [d-real-ref, real-ref-dyn]
    flags: [no_cse, no_hoist]
    description: Phi instruction

  - opcode: SpillFill
    base: SpillFillInst
    signature: []
    flags: [no_cse, no_dce]
    description: Pseudo instruction that inserted by Register Allocator.

  - opcode: SaveState
    base: SaveStateInst
    signature: [d-real-pseudo, real-dyn]
    flags: [no_hoist, no_cse]
    description: >-
      Contains information about virtual registers that must be saved before leaving compiled code. Constructed for all
      call instructions and all instructions that can throw.

  - opcode: SafePoint
    base: SaveStateInst
    signature: [real-dyn]
    flags: [no_dce, no_hoist, no_cse, barrier, runtime_call]
    description: GC safepoint instruction.
    codegen:
      - ld_16  tmp_u16, safepoint_state
      - jneq  tmp_u16, 0x0, safepoint_label
      - bind  back_safepoint_label

  - opcode: SaveStateDeoptimize
    base: SaveStateInst
    signature: [d-real-pseudo, real-dyn]
    flags: [no_dce, no_hoist, no_cse, barrier]
    modes: [jit_aot, bytecode_opt]
    description: >-
      Contains information about virtual registers that must be saved before leaving compiled code. Constructed for all
      loop pre-headers.

  - opcode: SaveStateOsr
    base: SaveStateInst
    signature: [d-real-pseudo, real-dyn]
    flags: [no_dce, no_hoist, no_cse, barrier]
    modes: [jit_aot]
    description: >-
      Contains information about virtual registers to fill OSR stackmaps. Constructed for all loop headers in OSR mode.

  - opcode: Select
    base: SelectInst
    signature: [d-real, real, real, real, real]
    flags: [low_level, ifcvt]
    modes: [jit_aot, irtoc]
    description: Select which value to move to destination based on comparison.

  - opcode: SelectImm
    base: SelectImmInst
    signature: [d-real, real, real, real]
    flags: [low_level, ifcvt]
    modes: [jit_aot, irtoc]
    description: Select which value to move to destination based on comparison with immediate.

  - opcode: AddOverflow
    base: BinaryOverflowInst
    signature: [d-int, int, int]
    flags: [cf, no_dce, no_hoist, no_cse, barrier, acc_read]
    modes: [jit_aot, irtoc]
    description: Add two values and check result to Overflow, in case of overflow and CC is EQ jump to true edge

  - opcode: SubOverflow
    base: BinaryOverflowInst
    signature: [d-int, int, int]
    flags: [cf, no_dce, no_hoist, no_cse, barrier, acc_read]
    modes: [jit_aot, irtoc]
    description: Sub two values and check result to Overflow, in case of overflow and CC is EQ jump to true edge

  - opcode: AddOverflowCheck
    base: FixedInputsInst3
    signature: [d-int, int, int, save_state]
    flags: [no_dce, no_hoist, no_cse, barrier, acc_read, require_state, can_deoptimize]
    modes: [jit_aot]
    description: Add two values, deoptimize if overflow occurred.

  - opcode: SubOverflowCheck
    base: FixedInputsInst3
    signature: [d-int, int, int, save_state]
    flags: [no_dce, no_hoist, no_cse, barrier, acc_read, require_state, can_deoptimize]
    modes: [jit_aot]
    description: Sub two values, deoptimize if overflow occurred.

  - opcode: If
    base: IfInst
    signature: [real, real]
    flags: [cf, no_dce, no_hoist, no_cse, barrier, low_level, acc_read]
    description: Performs compare and jump.

  - opcode: IfImm
    base: IfImmInst
    signature: [real]
    flags: [cf, no_dce, no_hoist, no_cse, barrier, acc_read]
    description: Performs compare with immediate and jump.

  - opcode: NOP
    base: FixedInputsInst0
    signature: []
    flags: [no_dst, ifcvt]
    description: Pseudo instruction, that replaces instruction to be deleted.

  - opcode: Try
    base: TryInst
    signature: []
    flags: [no_dce, no_hoist, no_cse, barrier]
    modes: [jit_aot, bytecode_opt]
    description: Pseudo instruction, inserted in the beginning of try-block.

  - opcode: CatchPhi
    base: CatchPhiInst
    signature: [d-real-ref, real-ref-dyn]
    flags: [no_hoist, no_cse]
    modes: [jit_aot, bytecode_opt]
    description: >-
      Pseudo instruction, which is inserted in the Catch handler basic block, and defines virtual registers at each throwing
      instruction of the appropriate try-block.

  - opcode: LiveIn
    base: Inst
    signature: [d-real]
    flags: [no_dce, no_hoist, no_cse, low_level]
    modes: [irtoc]
    description: Pseudo instruction, that define live-in register.

  - opcode: LiveOut
    base: FixedInputsInst1
    signature: [d-real, real]
    flags: [no_dce, no_hoist, no_cse, low_level]
    modes: [irtoc]
    description: Pseudo instruction, that define live-out register.

pseudo_instructions:
  - opcode: Else
    flags: [pseudo, cf]
  - opcode: While
    flags: [pseudo, cf]
  - opcode: Goto
    flags: [pseudo, cf]
  - opcode: Label
    flags: [pseudo, cf]
  - opcode: Register
    signature: [d-real]
    flags: [pseudo]
  - opcode: WhilePhi
    flags: [pseudo]

types:
  - name: i8
  - name: i16
  - name: i32
  - name: i64
  - name: u8
  - name: u16
  - name: u32
  - name: u64
  - name: f32
  - name: f64
  - name: bool
  - name: ref
  - name: ptr
  - name: void
  - name: any

arch_info:
- name: arm64
  regs_count: 32
  temp_regs: [16, 17, 20]
  fp_regs_count: 32
  fp_temp_regs: [30, 31]

- name: arm32
  regs_count: 16
  temp_regs: [8, 9, 12]
  fp_regs_count: 32
  fp_temp_regs: [14, 15]

- name: x86_64
  regs_count: 16
  temp_regs: [12, 13, 14]
  fp_regs_count: 16
  fp_temp_regs: [13, 14, 15]

legend:
  "Operand tokens":
    d: operand is a destination, operand is a source when 'd' is not specified
    i8: signed 8-bit integer
    i16: signed 16-bit integer
    i32: signed 32-bit integer
    i64: signed 64-bit integer
    u8: unsigned 8-bit integer
    u16: unsigned 16-bit integer
    u32: unsigned 32-bit integer
    u64: unsigned 64-bit integer
    f32: single precision float
    f64: double precision float
    bool: boolean type
    ref: object reference type
    ptr: pointer type
    void: void type
    int: type union of [bool, i8, i16, i32, i64, u8, u16, u32, u64]
    float: type union of [f32, f64]
    number: type union of [int, float]
    real: type union of [number, ref]
    any: the type is not statically defined(For dynamic languages)
    pseudo: pseudo destination - instruction doesn't actually write to the register
    zc: zero check - input must be the ZeroCheck instruction
    bc: bounds check - input must be the BoundsCheck instruction
    nc: null check - input must be the NullCheck instruction
    ngc: negative check - input should be the NegativeCheck instruction
    save_state: definition of the given input must be SaveState instruction
    dyn: dynamic operands, means that operand can repeat zero or more times

verification:
  equal_type_classes: |
    Type classes of instruction's operands are equal. Type classes are int, float, ref (see operand_tokens for info)
  float_src_eq_dst_size: |
    If instrucion's type is float then size of source operands shall be equal to size of destination.
  integer_src_ge_dst_size: |
    If instrucion's type is integer then size of source operands shall be greater than or equal to size of destination.
  start_block_instruction: |
    Instruction can only reside in start basic block.

flags:
  cf: Instruction affects control flow
  terminator: Execution will be terminated at the given instruction
  load: Instruction loads from memory
  store: Instruction stores into memory
  can_throw: Instruction can throw exception
  call: Call instruction.
  is_check: Instruction has runtime-checks and has `can_throw` flag
  no_dce: Instruction that can't be deleted on DCE
  no_cse: Instruction has unique vn class and CSE can't be applied
  no_dst: Instruction has no destination operand
  pseudo_dst: Instruction has pseudo destination operand, i.e. it doesn't affect on dataflow
  implicit_runtime_call: Instruction may call runtime before loading source, which can be moved by GC during that call
  low_level: Low level instruction
  no_hoist: Instruction can't be hoisted
  barrier: Instruction is a barrier for scheduling
  ref_special: Instruction which can not be moved throught runtime calls
  ifcvt: Instruction can be used in if-conversion
  require_state: Instruction may call runtime, thus, it requires SaveState in the inputs
  runtime_call: Instruction must call runtime
  commutative: Instruction is commutative(Add, OR, And e.t.c.)
  alloc: Instruction that allocates a new object on the heap
  acc_read: Read the accumulator register
  acc_write: Write the accumulator register
  heap_inv: Invalidates heap
  mem_barrier: we need encode memory barrier after the instruction(for return.void before)
  native: Instruction is used to generate unmanaged (native) code
  can_deoptimize: deoptimization may occur with jump to the interpreter

modes:
  jit_aot: JIT or AOT compiler
  bytecode_opt: Bytecode optimizer
  irtoc: Ir-To-Code tool
